\documentclass[a4paper, 11pt]{report}
\usepackage[margin=2.5cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{tikz-uml}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{tikz}
\usetikzlibrary{decorations,arrows.meta,shapes,automata,positioning,background}
\usepackage{listings}
\lstset{basicstyle=\footnotesize, tabsize=2}
\tikzumlset{fill class=black!5, fill component=white, fill usecase=black!10, fill object=black!10}

\title{Implémentation d'une API HTTP de style REST pour Apache OFBiz}
\author{Mathieu Lirzin}
\date{30 août 2018}

\begin{document}

\maketitle

\begin{abstract}
  Ceci est un rapport de stage de fin d'études effectué au sein de la
  société Néréide. Ce stage a consisté à mettre en place une API HTTP
  basée sur le style architectural REST pour les échanges entre
  différents composants logiciels du framework Apache OFBiz pour
  réorienter l'Architecture Orienté Service (SOA) de ce framework.
\end{abstract}

\tableofcontents

\chapter*{Introduction}

Ceci est un rapport de stage de fin d'études de Master 2 Informatique
de l'Université de Bordeaux effectué au sein de la société Néréide
pendant une durée de 5 mois entre le 2 Avril et le 30 Août 2018.

Le sujet de ce stage a consisté à mettre en place une API HTTP basée
sur le style architectural REST pour les échanges entre les différents
composants logiciels du framework Apache OFBiz. Cela a consisté dans
une première phase à réaliser un état de l'art de l'utilisation de ce
style architectural, puis à étudier les principes d'architectures
orientées services (SOA) utilisés dans le framework Apache OFBiz.
Dans une deuxième phase l'API HTTP basée sur le style REST a été
implementée au sein du framework Apache OFBiz en suivant les principes
SOA. Ces améliorations ont été réalisées en interaction avec la
communauté Apache OFBiz afin de permettre leurs intégrations dans les
prochaines versions.

Nous allons dans un premier temps faire une présentation de la société
d'accueil. Dans un deuxième temps nous présenterons le framework sur
lequel s'est basé le travail effectué lors de ce stage qui sera, lui,
présenté dans un troisième temps.

\chapter{Présentation de l'entreprise}

Néréide est une société de service en logiciel libre fondée en 2004
spécialisée dans l'intégration du progiciel de gestion intégré Apache
OFBiz.  Il s'agit d'une société coopérative et participative (SCOP)
dont le siège social est situé à Tours.  Les activités de la société
se décomposent en différents axes:

\begin{description}
\item[Dévéloppement spécifique] L'intégration du framework OFBiz
  implique généralement des développements spécifiques pour s'adapter au
  différents composants du système d'information existant.
\item[Maintenance et support applicatif (TMA)] Prestation de support
  et de maintenance corrective et/ou évolutive pour les développements
  spécifiques précédemment fait
\item[Administration système] mettre en place un élément système, un
  réseau, intégrer et migrer des composants systèmes.
\end{description}

Néréide s'appuie sur le réseau Libre Entreprise dont elle fait partie
pour proposer des services tels que l'hébergement, de formation.
L'équipe est actuellement composée de 11 personnes, ayant pour point
commun une expertise fonctionnelle sur OFBiz.

\chapter{Présentation de OFBiz}

Apache \emph{Open For Business} (OFBiz) est un framework Web ayant
pour but de faciliter la construction de progiciels de gestion
intégré.  Cet objectif est réalisé au moyen d'un modèle de données
générique et d'un ensemble de modules dédiés à des tâches communes à la
plupart des entreprises, telles que la comptabilité, la facturation,
ou la gestion des stocks.

OFBiz a été créé en 2001 par David E. Jones et Andy Zeneski dans
l'idée de développer une solution commune aux différentes
problématiques rencontrées par les entreprises en utilisant un modèle
de développement en logiciel libre. En janvier 2006 OFBiz a été accepté
dans l'incubateur de la fondation Apache avant d'être accepté en tant
que projet à part entière en décembre 2006.

\section{Architecture générale}

Techniquement OFBiz est basé sur la plateforme Java et sur
l'utilisation de \emph{langage spécifique au domaine} (DSL) basé sur
des grammaires XML.  Concenant le coeur du framework, les
communications HTTP sont gérés par des Servlets \cite{chan2017servlet}
et les communications avec les bases de données se font au moyen de
l'API Java JDBC.  Au dessus de cela, la déclaration des routes HTTP,
des écrans et des services se fait dans des fichiers XML faisant
référence à des implementations de services généralement en Java et
Groovy. Les écrans sont quant à eux basés sur Freemarker qui est un
langage de templating.

\begin{figure}
  \centering
  \begin{tikzpicture}
    \tikzstyle{engine}=[draw, thick, rectangle, node distance=10pt, fill=white];
    \node[engine] (entity) {entity engine};
    \node[engine, right=of entity] (service) {service engine};
    \node[engine, right=of service] (screen) {screen engine};

    \tikzstyle{elem}=[rounded rectangle, node distance=7pt];
    \tikzstyle{elemc}=[fill=black!30, elem];
    \tikzstyle{elems}=[fill=red!30, elem];
    \tikzstyle{eleme}=[fill=yellow!30, elem];
    \tikzstyle{elemw}=[fill=blue!30, elem];
    \node[elemw] at (0,7) (webapp1) {webapp};
    \node[elemw, below=of webapp1] (webapp2) {webapp};
    \node[elemc, below=of webapp2] (container1) {container};
    \node[elems, below=of container1] (service1) {service};
    \node[elems, below=of service1] (service2) {service};
    \node[eleme, below=of service2] (entity1) {entity};

    \node[elemw, node distance=40pt, right=of webapp1] (webapp3) {webapp};
    \node[elems, below=of webapp3] (service3) {service};
    \node[elems, below=of service3] (service4) {service};

    \node[eleme, node distance=40pt, right=of webapp3] (entity3) {entity};
    \node[eleme, below=of entity3] (entity4) {entity};
    \node[eleme, below=of entity4] (entity5) {entity};
    \node[elems, below=of entity5] (service5) {service};
    \node[elems, below=of service5] (service6) {service};

    \node[elemw, node distance=60pt, right=of entity3] (webapp4) {webapp};
    \node[elems, below=of webapp4] (service7) {service};
    \node[elems, below=of service7] (service8) {service};
    \node[elems, below=of service8] (service9) {service};
    \node[elems, below=of service9] (service10) {service};

    \tikzstyle{cmpt}=[rectangle, thick, rounded corners, draw=black!80, inner sep=8];
    \node[cmpt, fit=(webapp1)(webapp2)(container1)(service1)(service2)(entity1),
      label=above:\emph{composant A}] (cmpta) {};
    \node[cmpt, fit=(webapp3)(service3)(service4),
      label=above:\emph{composant B}] (cmptb) {};
    \node[cmpt, fit=(service5)(service6)(entity3)(entity4)(entity5),
      label=above:\emph{composant C}] (cmptc) {};
    \node[cmpt, fit=(webapp4)(service7)(service8)(service9)(service10),
      label=above:\emph{plugin X}] (pluginx) {};

    \begin{scope}[on background layer]
      \tikzstyle{bg}=[rectangle, rounded corners=10pt, fill=black!10, inner sep=15]
      \node[bg, fit=(entity) (service) (screen), label=right:\emph{\textsc{Framework}}] (framework) {};
      \node[bg, fit=(cmpta) (cmptb) (cmptc), label=above:\emph{\textsc{Applications}}] (apps) {};
    \end{scope}

    \tikzstyle{dep}=[-{Latex[length=7pt]}, densely dashed]
    \draw[dep] (cmpta.south) -- (entity);
    \draw[dep] (cmpta.south) -- (service);
    \draw[dep] (cmpta.south) -- (screen);
    \draw[dep] (cmptb.south) -- (service);
    \draw[dep] (cmptb.south) -- (screen);
    \draw[dep] (cmptc.south) -- (entity);
    \draw[dep] (cmptc.south) -- (service);
    \draw[dep] (pluginx.south) -- (screen);
    \draw[dep] (pluginx.south) -- (service);
    \draw[dep] (pluginx) -- (cmptc.east);
    \draw[dep] (cmptb) -- (cmpta.east);
  \end{tikzpicture}
  \caption{Dépendances entre les composants et le framework}
  \label{fig:compdep}
\end{figure}

OFBiz est structuré en séparant le framework, les applications, et les
plugins. Le framework fournit les mécanismes de communications réseau
et d'interfacage entre les différentes applications. Les plugins sont
des applications spécifiques qui ont la spécificité de dépendre des
applications de base mais dont aucune application de base ne dépend.
OFBiz est décomposé en plusieurs composants qui sont regroupés en
plusieurs catégories ou meta-composants. Ainsi les composants
fondamentaux définissant l'architecture d'OFBiz sont contenus dans
l'ensemble de composants \emph{Framework}.  Les composants
fonctionnels fondamentaux tels que la comptabilité, la facturation, ou
la gestions des stock sont regroupés dans l'ensemble de composants
\emph{Applications}.  Les composants spécifiques sont eux mis dans la
catégories \emph{Plugins}. Un point important dans la relation entre
ces différents composants est qu'il est important que les relations de
dépendances entre les méta composants soient respectés comme cela est
représenté sur la figure \ref{fig:compdep}.  Cela permet entre autre
de développer les plugins dans un dépôt externe.  Nous allons dans les
sections suivantes détailler le contenu et l'architecture des deux
méta-composants \emph{Framework} et \emph{Applications}.

\section{Le framework}

Le framework fournit les éléments de base définissant l'architecture
d'OFBiz ainsi que des outils de maintenance permettant d'intéragir
avec une instance d'OFBiz en cours d'exécution. Nous présentons ici
les concepts et élements fondamentaux pour comprendre l'organisation
de l'architecture du framework.

\subsection{Container}

\begin{figure}
  \centering
  \begin{tikzpicture}
    \umlinterface[]{Container}{}{
      \umlvirt{+ init(cmds : List<StartupCommand>, name : String,} \\
      \umlvirt{\hspace{1,1cm}config : String) : void} \\
      \umlvirt{+ start() : void} \\
      \umlvirt{+ stop() : void} \\
      \umlvirt{+ getName() : String}
    }

    \umlclass[x=5,y=-4]{StartupCommand}{
      - name : String \\
      - properties : Map<String, String>
    }{
      \umlvirt{+ getName() : String} \\
      \umlvirt{+ getProperties() : Map<String, String>}
    }

    \umldep[geometry=|-]{Container}{StartupCommand}

  \end{tikzpicture}
  \caption{Définition du type container}
  \label{fig:containertype}
\end{figure}

Un container est l'élément de plus bas niveau que définit OFBiz. Un
container est un processus tournant en tâche de fond pouvant être
initialisé, démarré et arreté. Concrètement cela est représenté par
l'interface \verb=Container= représentée sur la figure
\ref{fig:containertype}. OFBiz ne définit par défaut qu'un seul
container dans un fichier \verb=ofbiz-container.xml= et il est
possible pour chacun des composants de définir leurs propres
containers. L'intérêt de cette abstraction est de permettre de lier
l'exécution un daemon externe au lancement de OFBiz. Ainsi le plugin
OFBiz Camel définit un container pour le runtime de Apache Camel en
charge de faire communiquer les différents points de sorties. Un
container est paramétré par un ensemble de phases décrites dans
l'attribut \verb=loaders= du container. Cet attribut détermine à
quelles phases ce container doit être démarré. Les trois phases suivantes
sont définies:
\begin{description}
\item[main] la phase d'exécution de ofbiz
\item[load-data] la phase de chargement des données dans la base de
  données
\item[test] la phase de lancement des tests d'intégrations
\end{description}

\subsection{Composants}

Un composant est une abstraction permettant de séparer les différentes
fonctionnalités de OFBiz. Un composant est une agglomération de
containers, entités, services, écrans, et applications Web. Un
composant est définit au moyen d'une structure XML stockée dans le
fichier \verb=ofbiz-component.xml= qui est à la racine du répertoire
contenant l'ensemble des définitions qu'il contient.  La figure
\ref{fig:ofbizcomponent} montre l'exemple du composant \emph{Webtools}
qui fait référence à deux fichiers contenant des définitions
d'entités, à un fichier de service et à une application Web.

\begin{figure}
  \begin{lstlisting}[language=xml]
<ofbiz-component name="webtools"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://ofbiz.apache.org/dtds/ofbiz-component.xsd">
  <resource-loader name="main" type="component"/>
  <classpath type="dir" location="config"/>

  <entity-resource type="data" reader-name="seed" loader="main"
                   location="data/WebtoolsSecurityPermissionSeedData.xml"/>
  <entity-resource type="data" reader-name="demo" loader="main"
                   location="data/WebtoolsSecurityGroupDemoData.xml"/>
  <service-resource type="model" loader="main" location="servicedef/services.xml"/>
  <webapp name="webtools"
          title="WebTools"
          menu-name="secondary"
          server="default-server"
          location="webapp/webtools"
          base-permission="OFBTOOLS,WEBTOOLS"
          mount-point="/webtools"/>
</ofbiz-component>
  \end{lstlisting}
  \caption{Définition du composant Webtools}
  \label{fig:ofbizcomponent}
\end{figure}

L'élément \verb=resource-loader= définit de quelle manière ce
composant sera chargé par OFBiz. L'élément \verb=classpath= définit le
chemin vers des ressources telles que les traductions de label contenues
dans le dossier pointé par l'attribut \verb=location=. Concernant les
éléments \verb=entity-resource= il est possible d'avoir des types
"model" ou "data". La différence étant que "model" contient des
définitions d'entités et "data" contient des exemples de données qui
servent à fournir des données d'exemples.

\subsection{Applications Web}

Chaque composant peut définir des applications web qui sont une
extension du modèle des servlets et sont montés dans un serveur
d'applications partagé par tous les composants. Généralement un
composant possède une application mais il est possible d'en avoir
plusieurs dans un même composant. Dans le cas du méta-composant
\emph{Framework} il n'y a qu'une seule application Web qui est associée
au composant \emph{Webtools}. Les composants contenus dans
\emph{Applications} ont presque tous au moins une application Web
associés. Il est a noter que bien qu'OFBiz soit basé sur l'architecture
des servlets il n'est pas possible de déployer les différentes
applications Web dans un serveur d'application externe dans la mesure
où le processus de compilation d'OFBiz embarque dans un même JAR
l'ensemble des applications web ainsi que le serveur d'application.
Classiquement la définition des routes pour les servlet se fait dans
un fichier \verb=web.xml=. Dans le cas d'OFBiz ce routage est délégué
à un fichier \verb=controller.xml= associant les différents
traitements à des routes HTTP ainsi que les écrans qui seront
retournés suite à ces traitements. Seules les requêtes \verb=POST= et
\verb=GET= sont traitées du fait que le client est uniquement prévu
pour être un navigateur. Il n'y a pas de différences dans le traitement
des requêtes. Peu importe la méthode choisie cela a pour effet
d'appeler l'événement associé. La figure \ref{fig:controller}
présente une partie du fichier \verb=controller.xml= du composant
\emph{Webtools}.

\begin{figure}
  \begin{lstlisting}[language=xml]
<site-conf xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xmlns="http://ofbiz.apache.org/Site-Conf"
	   xsi:schemaLocation="http://ofbiz.apache.org/Site-Conf...">
  <include location="component://common/webcommon/WEB-INF/common-controller.xml"/>
  <include location="component://common/webcommon/WEB-INF/portal-controller.xml"/>
  <include location="component://common/webcommon/WEB-INF/security-controller.xml"/>
  <include location="component://common/webcommon/WEB-INF/tempexpr-controller.xml"/>
  <description>WebTools Site Configuration File</description>
  <handler name="ftl" type="view"
           class="org.apache.ofbiz.webapp.ftl.FreeMarkerViewHandler"/>
  ...
  <request-map uri="ping">
    <event type="service" invoke="ping"/>
    <response name="error" type="view" value="ping"/>
    <response name="success" type="view" value="ping"/>
  </request-map>
  ...
  <view-map name="ping" type="ftl" page="component://webtools/template/Ping.ftl"/>
  ...
</site-conf>
  \end{lstlisting}
  \caption{Définition du contrôleur de Webtools}
  \label{fig:controller}
\end{figure}

\subsection{Moteur d'entités}

\begin{figure}
  \centering
  \begin{tikzpicture}
    \umlclass[]{GenericEntity}{
      - internalDelegator : Delegator
    }{}

    \umlsimpleclass[x=6]{Delegator}

    \umlclass[y=-4]{GenericValue}{
    }{
      \umlvirt{+ store() : void} \\
      \umlvirt{+ remove() : void} \\
      \umlvirt{+ refresh() : void} \\
      \umlvirt{+ refreshFromCache() : void} \\
      \umlvirt{+ getRelated(field: String) : List<GenericValue>} \\
      ...
    }

    \umlinherit[geometry=-|]{GenericValue}{GenericEntity}
    \umldep{GenericEntity}{Delegator}

  \end{tikzpicture}
  \caption{Définition du type valeur générique}
  \label{fig:genericvalue}
\end{figure}

Un point crucial d'un framework comme OFBiz est l'accès aux bases de
données.  Pour cela OFBiz possède un moteur d'entités pour communiquer
à les système de base de données relationnelles.  Ce moteur d'entités
permet à la fois de définir des schémas adaptés au différent SGBD au
moyen d'un modèle entité-relation avec des types de données génériques
associé à des types concrets adaptés à l'implémnentation cible. Un
deuxième aspect est la construction de requêtes SQL au sein des
programmes Java et Groovy au moyen d'un DSL utilisant le pattern
\emph{builder} \cite{gamma1993design}. Lors que ces requêtes sont
envoyés, leur résultat retourne des valeurs « actives » c'est à dire
gardant une référence sur la connexion à la base de données pour
pouvoir sauvegarder en base les modifications faites en sur ces
objets.  Cela correspond au pattern architectural \emph{active record}
\cite{fowler2002patterns}.  La figure \ref{fig:genericvalue}
représente les relations entre ces valeurs « actives » représenté par
la classe \verb=GenericValue= et la connexion à la base de données
représenté par la classe \verb=Delegator=.

\subsection{Moteur de services}

\begin{figure}
  \centering
  \begin{tikzpicture}
    \umlinterface[]{GenericEngine}{}{
      \umlvirt{+ runSync(name : String, m : ModelService,
        context : Map) : Map} \\
      \umlvirt{+ runSyncIgnore(name : String, m : ModelService,
        context : Map) : void} \\
      \umlvirt{+ runAsync(name : String, m : ModelService, context : Map,} \\
      \umlvirt{\hspace{2cm}r : GenericRequester, persist : boolean): void} \\
      \umlvirt{+ runAsync(localName : String, m : ModelService,} \\
      \umlvirt{\hspace{2cm}persist : boolean): void} \\
      \umlvirt{+ sendCallBacks(m : ModelService,
        context : Map, mode : int) : void} \\
      \umlvirt{+ sendCallBacks(m : ModelService,
        context : Map, result : Map,
        mode : int) : void} \\
      \umlvirt{+ sendCallBacks(m : ModelService,
        context : Map, t : Throwable, mode : int) : void} \\
    }
  \end{tikzpicture}
  \caption{Définition du type service}
  \label{fig:serviceengine}
\end{figure}

OFBiz est basé sur une architecture orientée service (SOA).  La notion
de moteur de service est définit par l'interface Java
\verb=GenericEngine= représenté sur la figure \ref{fig:serviceengine}.
Un service peut être appelé en lui passant un contexte en entrée, il
renvoie alors une \emph{Map} permettant de récupérer le type de retour
conventionnellement nommé "success", "error", ou "fail" ainsi que les
données renvoyées par le service.  Il est possible d'exécuter un
service soit de manière synchrone avec les méthodes \verb=runSync= ou
\verb=runSyncIgnore= soit de manière asynchrone avec les méthodes
\verb=runAsync=.  Les méthodes \verb=sendCallBacks= permettent
d'exécuter des traitements associé de manière \emph{ad hoc} à un
service. Ces méthodes sont considéré comme obsolètes et on été
remplacée par l'utilisation des \emph{Event Condition Access} (ECA)
décrit plutard. Dans la pratique les services sont exécutés la plupart
du temps de manière synchrone.  Un service à accès au moteur d'entités
pour manipulés les données et au moteur de services pour appeler
d'autres services.

Il existe plusieurs implémentations de cette interface parmi
lesquelles on trouve les classes \texttt{EntityAutoEngine},
\texttt{StandardJavaEngine}, et \texttt{GroovyEngine}.  Cela permet
d'écrire des services dans différents langages de programmation ou
même par des services distant ce qui est le cas du moteur de services
\verb=XMLRPCClientEngine=. Il est possible pour les plugins de fournir
leur propre implémentation de services à fin de faire communiquer
OFBiz avec d'autres composants logiciels.

Les ECA permettent d'exécuter des traitement à différentes phases de
l'exécution d'un service.  Les différentes phases existantes sont
"auth", "in-validate", "out-validate", "invoke", "commit", et
"return".

\subsection{Moteur d'écrans}

\begin{figure}
  \centering
  \begin{tikzpicture}
    \umlinterface[]{ViewHandler}{}{
      \umlvirt{+ setName(name : String) : void} \\
      \umlvirt{+ getName() : String} \\
      \umlvirt{+ init(context : ServletContext) : void} \\
      \umlvirt{+ render(name : String, page : String, info : String,} \\
      \umlvirt{\hspace{1.4cm} contentType : String, encoding : String,} \\
      \umlvirt{\hspace{1.4cm} req : HttpServletRequest, resp : HttpServletResponse) : void}
    }
  \end{tikzpicture}
  \caption{Définition du type gestionnaire de vues}
  \label{fig:viewhandler}
\end{figure}

Afin de fournir des écrans, OFBiz possède un DSL pour définir des
écrans, formulaire, widget auquel est associé un mécanisme de rendu
générique permettant de générer différents formats de sortie tels que
HTML, XML, CSV, ou XLS.  Ce mécanisme de rendu est défini par
l'interface \verb=ViewHandler= défini sur sur la figure
\ref{fig:viewhandler}.  L'implémentation principale utilisé par la
plupart des moteur d'écrans existant est la classe
\verb=MacroScreenViewHandler=.  Elle délègue le rendu au mécanisme de
templating Apache Freemarker.  Dans le cas du moteur d'écran HTML
l'inclusion des scripts Javascript permettant d'apporter du dynamisme
et d'effectuer des appels AJAX \cite{garrett2005ajax} à des services
OFBiz est fait directement dans la définition des macros Freemarker.
Chaque vue (\verb=view-map=) définit dans le fichier
\verb=controller.xml= doit faire référence explicitement à
l'implémentation du moteur d'écran de son choix dans l'attribut
\verb=type= qui fait référence à un élément \verb=handler=.

\begin{lstlisting}[language=xml]
<handler name="screen" type="view"
         class="org.apache.ofbiz.widget.renderer.macro.MacroScreenViewHandler"/>
<view-map name="login" type="screen"
          page="component://common/widget/CommonScreens.xml#login"/>
\end{lstlisting}

Sauf exception l'ensemble ces éléments sont définis dans le fichier
\verb=common-controller.xml=.  Il peut définir à la fois des
gestionnaires de rendu d'écran et des gestionnaires de requêtes HTTP
couramment appelés \emph{événements} dans le contexte d'OFBiz.

\section{Les applications}

Après avoir décrit les éléments définis dans le méta-composant
\emph{Framework}, nous présentons le méta-composant
\emph{Applications} contenant des composants métiers c'est à dire des
composants associé à un type d'application fonctionnels.  Ainsi nous
avons les composants suivants:

\begin{description}
\item[accounting] définit des services et écrans pour effectuer de la
  comptabilité.
\item[commonext] est une extension du composant \emph{common} du
  \emph{Framework} contenant des dépendances fonctionnelles
\item[content] définit des service et écrans pour créer des contenus
  divers tel que des articles, photos, vidéos, pour par exemple
  maintenir un blog.
\item[datamodel] contient la définition des entités
  applicatives et des relations entre ces entités.
\item[humanres] définit des service et écrans pour la gestion du
  personnel
\item[manufacturing] définit des service et écrans pour la gestion des
  processus industriel et de stockage.
\item[marketing] définit des service et écrans pour la communication
  d'entreprise
\item[order] définit des service et écrans pour le traitement des commandes
\item[party] définit des service et écrans pour la gestions des
  partenaires et clients.
\item[product] définit des service et écrans pour la gestions du
  catalogue de produit et services.
\item[securityext] est une extension du composant \emph{security} qui
  définit des services ayant des dépendances fonctionnelles.
\item[workeffort] définit des services et écrans pour la gestion de
  projet et le suivi de tâches (pointage).
\end{description}

Cet ensemble de composants est le coeur fonctionnel d'OFBiz, il sert
de socle pour les composants spécifiques qui sont définit dans au
niveau des plugins.

\chapter{État de l'art}

Nous présentons dans ce chapitre le contenu de l'étude faite lors de
la première phase de ce stage.  Cette étude à consisté d'une part à
étudier de manière théorique le style architectural REST notamment au
travers des travaux de Roy Fielding.  D'autre part cela a consisté à
étudier des solutions existantes permettant de faciliter le
développement de service REST.  Ces deux aspects ont eu pour objectif
d'avoir une bonne compréhension des enjeux de ce style architectural,
et d'avoir une bonne connaissance des solutions existantes pour soit
en réutiliser une, soit trouver de l'inspiration pour l'implémentation
développé dans le cadre de OFBiz.

\section{Representational State Tranfer}

\emph{Representational State Transfer} (REST) est un style
architectural ayant émergé au début de l'année 1995.  Il s'agit d'un
modèle idéalisé décrivant comment le \emph{Web} devrait fonctionner
\cite{fielding2002principled}.  Il a été affiné pendant 5 ans jusqu'à
être décrit en détails par Roy Fielding dans sa thèse de doctorat
\cite{fielding2000architectural} en 2000.  Ce travail a eu une forte
résonnance dans les milieux non-académique du fait de l'essor du Web,
de ses qualités en terme de passage à l'échelle, mais également du
fait de sa simplicité.

\begin{figure}
  \centering
  \resizebox {0.8\columnwidth} {!} {
  \begin{tikzpicture}
    \tikzstyle{as}= [draw,rectangle,rounded corners=3pt]
    \tikzstyle{asc}= [draw,rectangle,rounded corners=3pt, fill=black!10]
    \tikzstyle{cst}= [right,scale=0.7]
    \node[as] (o) at (0, 10) [circle,fill] {};
    \node[as] (RR) at (-5, 8) {RR};
    \node[asc] (cache) at (-5, 6) {\$};

    \node[asc] (CS) at (-3, 8) {CS};
    \node[asc] (CSS) at (-3, 6) {CSS};
    \node[as] (CcacheSS) at (-3, 4) {C\$SS};

    \node[asc] (LS) at (0, 8) {LS};
    \node[as] (LCS) at (0, 6) {LCS};
    \node[as] (LCcacheSS) at (0, 4)  {LC\$SS};

    \node[as] (VM) at (2.8, 8) {VM};
    \node[asc] (COD) at (2.8, 6) {COD};
    \node[as] (LCODCcacheSS) at (2.8, 4) {LCODC\$SS};

    \node[asc] (U) at (5, 8)  {U};
    \node[as] (REST) at (5, 4) {REST};

    \draw[->] (o) edge [bend right=15] node[cst, left]{replicated} (RR);
    \draw[->] (o) edge [bend right=10] node[cst]{separated} (CS);
    \draw[->] (o) edge node[cst]{layered} (LS);
    \draw[->] (o) edge [bend left=2] node[cst]{programmable} (VM);
    \draw[->] (o) edge [bend left=15] node[cst,yshift=10]{uniform interface} (U);
    \draw[->] (RR) edge node[cst]{on-demand} (cache);
    \draw[->] (cache) edge node[cst, left]{cacheable} (CcacheSS);
    \draw[->] (CS) edge node[cst]{stateless} (CSS);
    \draw[->] (CSS) edge node[cst]{reliable} (CcacheSS);
    \draw[->] (LS) edge (LCS);
    \draw[->] (LCS) edge node[cst]{shared} (LCcacheSS);
    \draw[->] (VM) edge (COD);
    \draw[->] (COD) edge node[cst]{extensible} (LCODCcacheSS);
    \draw[->] (U) edge node[cst, text width=3cm, left,xshift=25, yshift=30]{simple visible reusable} (REST);
    \draw[->] (CS.east) edge node[cst, sloped, text
      width=2cm, centered]{intermediate processing} (LCS);
    \draw[->] (CS.east) edge[bend left=15, pos=0.75] node[cst]{mobile} (COD);
    \draw[->] (CcacheSS) edge node[cst,centered, yshift=10]{scalable} (LCcacheSS);
    \draw[->] (LCcacheSS) edge node[cst,left, text width=0.5cm]{multi-org} (LCODCcacheSS);
    \draw[->] (LCODCcacheSS) edge  (REST);
  \end{tikzpicture}
}
  \caption{Dérivation du style architectural REST}
  \label{fig:derivrest}
\end{figure}

Un style architectural est un ensemble de contraintes placées sur une
architecture logicielle c'est à dire une abstraction décrivant les
composants, les connecteurs, ainsi que les données présents au sein
d'un système \cite{perry1992foundations}. REST est composé des 6
contraintes représentés par les noeuds grisés du graphe de dérivation
de la figure \ref{fig:derivrest}.  Chacune de ces contraintes est
explicitée dans les descriptions suivantes:

\begin{description}
\item[Client-Serveur (CS)] Cette contrainte permet la séparation des
  préoccupations entre le(s) serveur(s) et le(s) client(s).
  Typiquement il est important de ne pas lier une interface
  utilisateur aux services rendus par le serveur, pour permettre la
  réutilisabilité des services et la variété des interfaces
  utilisateurs.  Dans un contexte distribué cela permet au client et
  au serveur d'évoluer indépendamment.

\item[Serveur sans état (CSS)] Chaque requête envoyé par le client
  doit pouvoir être traitée de manière indépendante.  Cela impose de
  transmettre dans chacune des requêtes les données permettant
  d'authentifier le client.  Cela rend l'architecture robuste dans la
  mesure où cela limite les contraintes d'ordre dans l'envoi de
  messages.  Dans un contexte avec plusieurs serveurs cela permet de
  passer simplement à l'échelle.  Cependant cette redondance
  d'informations entre les requêtes impose un surcout de transfert de
  données.

\item [Possible mise en cache (\$)] Pour contrecarrer ce sur-coût,
  REST impose de pouvoir spécifier dans les messages si les
  informations qu'ils contiennent peuvent être garder en cache et
  ainsi limiter le nombre de messages transmis sur le réseau.

\item[Interface uniforme (U)] Cette contrainte est centrale à REST et
  consiste dans la manipulation des ressources uniquement par leur(s)
  représentation(s), l'utilisation de messages auto-descriptif, et
  l'utilisation de \emph{l'hypermédia comme moteur de l'état de
    l'application}\footnote{plus connu sous sa forme anglaise
    \emph{Hypermedia As The Engine Of Application State} (HATEOAS)}

\item[En couches (LS)] Cette contrainte permet de limiter la
  complexité de l'architecture en revanche elle a l'inconvénient
  d'avoir un surcôut en terme d'exécution.

\item[Code à la demande (COD)] Ceci est une contrainte optionelle
  permettant au serveur d'étendre les fonctionnalités du client.
\end{description}

Cette combinaison de contraintes amène les propriétés architecturales
suivantes:
\begin{itemize}
\item Performance
\item Passage à l'échelle
\item Simplicité
\item Évolution
\item Visibilité
\item Portabilité
\item Fiabilité
\end{itemize}

Ce style architectural s'oppose principalement au style \emph{Remote
  Procedure Call} (RPC) qui souffre d'un problème de performance et
passage à l'échelle.  Ce style RPC se retrouve dans le cadre du Web
dans l'utilisation du protocole SOAP \cite{box2000simple} et
correspond au type des appels de services OFBiz. Malgré son succès
REST reste assez mal compris ainsi son application dans le cadre de
services Web que nous détaillons dans la partie suivante est souvent
mal comprise et on perd ainsi les propriétés d'évolution, portabilité,
et fiabilité.

\section{Architecture Web}

L'architecture Web est une instance du style architectural REST.  En
fait REST a été conceptualisé conjointement au World Wide Web pour
permettre de décrire de manière abstraite les enjeux d'un tel système.
Nous présentons ici les différents composants de cet architecture que
sont le protocole HTTP, les URI, et les formats de données tels que
HTML, XML, et JSON.

\subsection{Protocole HTTP}

\begin{figure}
  \centering
  \begin{tikzpicture}
    \begin{umlseqdiag}
      \umlbasicobject{Client}
      \umlbasicobject[x=8]{Serveur}
      \begin{umlcall}
        [padding=3,op={\texttt{GET /}}, return=\texttt{200 OK}]{Client}{Serveur}
      \end{umlcall}
      \begin{umlcall}
        [padding=3, dt=5, op={\texttt{POST /data}}, return=\texttt{201 Created} ]{Client}{Serveur}
      \end{umlcall}
      \begin{umlcall}
        [padding=3, dt=5, op={\texttt{DELETE /data/1780530}}, return=\texttt{204 No Content}]{Client}{Serveur}
      \end{umlcall}
    \end{umlseqdiag}
  \end{tikzpicture}
  \caption{Protocole HTTP}
  \label{fig:http}
\end{figure}

Le protocole \emph{Hypertext Transfer Protocol} (HTTP) est un
protocole texte utilisé sur le Web pour transmettre les ressources
HTML, CSS, Javascript.  Ce protocole appartient à la couche
application du modèle OSI et se base sur le protocole TCP dans la pile
TCP/IP. Il a un rôle particulier dans l'architecture \emph{Web}
puisqu'il sert à la fois à la communications entre les composants
\emph{Web} et est l'unique protocole de cette architecture intégrant
la notion de représentations de ressources.  L'accès aux ressources se
fait au au travers d'une URI et au moyen de 4 méthodes principales
\verb=GET=, \verb=POST=, \verb=HEAD=, \verb=DELETE= mais également de
5 autres méthodes moins courantes \verb=OPTIONS=, \verb=CONNECT=,
\verb=TRACE=, \verb=PUT=, \verb=PATCH=.  La figure \ref{fig:http}
montre un exemple de communication entre un client et serveur HTTP.
Les requêtes envoyées au serveur prenne la forme d'une ligne de
requête, un ensemble de header, et optionellement une charge utile.
Ainsi cet exemple de communication pourrait inclure la requête de la
figure \ref{fig:httpreq} et la réponse de la figure \ref{fig:httpres}.

\begin{figure}[h]
\begin{verbatim}
POST /data HTTP/1.1
Host: www.example.com
Content-Length: 14

lorem ipsum
\end{verbatim}
\caption{Requête HTTP}
\label{fig:httpreq}
\end{figure}

\begin{figure}[h]
\begin{verbatim}
HTTP/1.1 201 Created
Date: Mon, 23 May 2005 22:38:34 GMT
Content-Type: application/json; charset=UTF-8
Content-Length: 42

{
  "msg" : "Resource successfully created",
  "href" : "/hello/data/1780530"
}
\end{verbatim}
\caption{Réponse HTTP}
\label{fig:httpres}
\end{figure}

Le fait que les méthodes et les codes de retours soient contraint par
le protocol permet aux agents de faire des suppositions sur la manière
de traité la requête et la réponse.  Par exemple la méthode \verb=GET=
a comme propriété d'être \emph{nullpotent} c'est à dire qu'elle ne
doit pas modifier l'état des ressources, et la méthode \verb=PUT= a la
propriété d'être \emph{idempotent} c'est à dire que la réception de
plusieurs message ne doit produire qu'une seule action.  La méthode
\verb=POST= n'a aucune de ces propriétés.  La sémantique fixe attachée
aux méthodes permet aux différents mécanismes de cache d'agir de
manière efficace au sein de l'architecture Web et donc d'apporter les
propriétés de performance et de passage à l'échelle
\cite{fielding1999hypertext}.

\subsection{Uniform Resource Identifier}

Les \emph{Uniform Resource Identifiers} (URI) servent à nommer toute
sorte des ressources (document, images, service, ...)
\cite{masinter2005uniform}.  Les URI ne sont pas des emplacements et
ne sont donc pas liées à un serveur spécifique ce qui permet
d'utiliser des proxies.  Les URI permettent uniquement d'accéder à des
représentations et non directement à des ressources.  Cette
distinction permet une forme de polymorphisme en associant plusieurs
représentations à une même ressource.  En pratique l'accès à ces
représentations se fait au moyen du header \verb=Accept= présent dans
la requête émise vers une URI, qui dispatche alors vers la
représentation la plus adaptée.  Les URI peuvent à la fois référencer
des ressources statiques ou des ressources dynamiques.  Une ressource
$R$ est une fonction $M_r(t)$ associant à un temps $t$ une entité ou
valeurs.  L'ensemble des entités ou valeurs appartenant au codomaine
sont équivalentes en terme de leur sémantique.  Même si ces ressources
pointent sur la même valeur il s'agit bien de 2 ressources distinctes.
Ce qui identifie une ressource c'est la sémantique associé à son URI.

\subsection{Formats de données}

Lors d'une requête, il est possible pour le client de spécifier le
type contenu souhaité au moyen du header \verb=Accept= cependant il
faut que le serveur recevant cette requête soit en mesure de fournir
le format de donnée souhaité.  Dans la pratique les formats XML et
JSON sont les plus courants pour la transmission de données
structurées.  Un point important est que le format représente les
données transmises sous forme de structures arborescentes pouvant être
mis en correspondance avec les structures de données présentes dans la
plupart des langages de programmation.  A fin de permettre
l'implémentation de l'hypermédia qui est décrit dans la section
suivante, il est également important que le format choisi puisse être
associé à une sémantique. Cela est le cas par exemple du format HTML
mais pas de JSON.

\subsection{Hypermédia}

La notion d'\emph{hypermédia} est une extension de l'\emph{hypertexte}
à d'autres médias tels que les images, le son, et les vidéos.  Il
désigne un réseau d'information accessible de manière non-linéaire et
interactive au moyen de liens.  Cette notion est cruciale dans la
réalisation d'une API HTTP RESTful bien qu'elle soit trop souvent
négligé.  En suivant les principes de l'architecture REST, les URI ne
devraient pas constitué l'API.  L'API devrait être idéalement un point
d'entrée unique avec l'ensemble des ressources accessible en tant que
liens Hypermédia fournits par cette ressource dans le payload. Cela
permet de répondre en parti à la problématique du versioning en
limitant la surface d'attaque de l'API, et rendant l'accès aux
ressources essentiellement dynamique.  L'hypermédia permet d'apporter
les propriétés de découvrabilité et faible couplage.

\section{Implementations existantes}

En parallèle de cette analyse théorique, nous avons également étudié
les différentes solutions adoptés pour implémenter des API RESTful.
Nous nous intéressons ici à plusieurs frameworks et bibliothèques
ayant alimenté la réflexion autout des choix d'implémentations qui ont
été fait pour l'intégration de REST dans OFBiz.  Nous présentons donc
succintement les spécifications JAX-RS et OpenAPI ainsi que le
framework Vert.x.

\subsection{JAX-RS}

\emph{JAX-RS} est une API java permettant de créer des services Web «
RESTful » \cite{pericas2013jax}. Cette spécification est intégrée dans
\emph{JavaEE} et possède plusieurs implémentations dont Jersey qui est
l'implémentation de référence, RESTeasy, Restlet, et Apache CXF.
L'utilisation de Jersey est impossible du fait de l'incompatibilité de
sa license avec celle d'OFBiz.  Du fait de son intégration dans la
communauté Apache, CXF semble être une implémentation adapté à une
utilisation dans OFBiz.  L'avantage de cette solution est une
intégration et adoption forte dans l'univers JavaEE.  Du fait qu'OFBiz
est déjà couplé au JDK ce choix ne présente pas un grand risque. Cette
spécification utilise un système d'annotation comprenant les
annotations \verb=@Path=, \verb=@GET=, \verb=@POST=, \verb=@Produces=,
\verb=@Consumes= permettant d'associer les méthodes HTTP à des
méthodes Java pour une route donnée.

\subsection{Vert.x}

\emph{Vert.x} est un framework permettant de créer des API Web
Asynchrone.  Il s'inspire grandement de ce qui a été fait dans
\emph{Node.js} avec l'utilisation intensive de callback dans des
requêtes HTTP et les appels vers la base de données. Un point fort de
Vert.x est le fait que les traitements asynchrone soit bien intégré à
l'API. Cela permet d'écrire des traitements de requêtes de manière
relativment déclaratives grâce à des callbacks tout en ayant de bonnes
performances.  À la différence de JAX-RS, il n'y a pas de standard
pouvant donner une bonne confiance dans la pérénnité de Vert.x
d'autant que ce projet créé en 2011 reste relativement jeune.

\subsection{Apache Camel}

Apache camel est un framework implémentant un ensemble de patterns de
communications par envoi de messages décrits dans l'ouvrage «
Enterprise Integration Patterns » \cite{hohpe2003enterprise}. Une
solution intéressante proposé par ce framework et montré dans la
figure \ref{fig:restdsl} est la définition d'un langage spécifique
REST transposable à la fois en Java et en XML permettant de décrire
les routes et les handlers de traitement des types de requêtes
associés à ces routes.

\begin{figure}
  \ContinuedFloat*
  \begin{lstlisting}[language=java]
rest("/customers/")
  .get("/{id}").to("direct:customerDetail")
  .get("/{id}/orders").to("direct:customerOrders")
  .post("/neworder").to("direct:customerNewOrder");
  \end{lstlisting}
  \caption{REST DSL Java}
\end{figure}

\begin{figure}
  \ContinuedFloat
  \begin{lstlisting}[language=xml]
<rest path="/customers/">
  <get uri="/{id}">
    <to uri="direct:customerDetail"/>
  </get>
  <get uri="/{id}/orders">
    <to uri="direct:customerOrders"/>
  </get>
  <post uri="/neworder">
    <to uri="direct:customerNewOrder"/>
  </post>
</rest>
  \end{lstlisting}
  \caption{REST DSL XML}
  \label{fig:restdsl}
\end{figure}

\chapter{Réalisations}

\section{Analyse des besoins}

Afin de répondre au mieux aux besoins de ce stage, nous avons effectué
une analyse des besoins décomposer d'une part dans des besoins
fonctionnels pour décrire les fonctionnalités que devra avoir l'API
REST, et les besoins non-fonctionnels d'autre part pour décrire des
besoins qualitatifs ou des contraintes d'environnement ou de
développement.  Étant donné le mode de développement agile imposé par
le caractère communautaire du projet, cette analyse des besoins n'est
pas à voir comme un cahier des charges complet, mais comme une
description précise minimale de ce qui est attendu en terme de
développement et de manière de travailler.

\subsection{Besoins fonctionnels}

\begin{figure}
  \centering
  \begin{tikzpicture}
    \begin{umlsystem}[x=4]{API REST}
      \umlusecase[name=enti]{Manipuler entité}
      \umlusecase[name=hyper, y=-2, width=1.8cm]{Accèder à\\ une URI}
      \umlusecase[name=serv, y=-4]{Appeler service}
      \umlusecase[name=mrep, y=-5.5, width=2.5cm]{Recevoir/Envoyer\\représentation}
    \end{umlsystem}
    \umlactor[y=-4]{Client HTTP}
    \umlassoc{Client HTTP}{mrep}
    \umlassoc{Client HTTP}{hyper}
    \umlinclude{hyper}{enti}
    \umlinclude{hyper}{serv}
  \end{tikzpicture}
  \caption{Représentation des cas d'utilisation}
  \label{fig:needs}
\end{figure}

L'objectif de ce stage est de créer une API basée sur le protocole
HTTP et suivant le style architectural REST.  Actuellement les
traitements mis à disposition par OFBiz sont fournis au travers du
moteur de services accessible au moyen d'une interface HTTP de type
\emph{Remote Procedure Call} (RPC) et du moteur d'entités qui lui
n'est pas directement accessible par le réseau.  Le besoin premier
sous jacent à la création d'une API REST est de fournir une interface
orienté ressources aux moteurs de services et d'entités.  L'accès aux
ressources se fait au moyen d'une \emph{Uniform Resource Identifier}
(URI) à laquelle le client HTTP envoit une requête HTTP avec une
méthode (GET/POST/PUT...) adapté à la sémantique du traitement que le
client HTTP veut effectué.  Les requêtes utilisant les méthodes
POST/PUT incluent une charge utile prenant la forme d'une
représentation de ressource, permettant de créer ou modifier des
données sur le serveur.  Lors du traitement d'une requête par le
serveur, cela a pour effet d'appeler des services OFBiz et/ou de faire
des accès en base de données au moyen du moteur d'entités pour
manipuler des entités.  À partir de ces traitements le serveur envoit
ensuite une représentation de la ressource requêtée avec un code
d'erreur adapté à la sémantique du traitement effectué.  Ceci est
représenté de manière simplifié par le diagramme des cas d'utilisation
de la figure \ref{fig:needs}.

\subsection{Besoins non-fonctionnels}

La solution proposés devra s'intégrer dans le framework. Ainsi il est
important de peser tout ajout de dépendances.  En effet le fait de
dépendre d'un autre framework a l'avantage de ne pas avoir à
réimplémenter les services fournit par ce framework mais impose
d'avoir une forte confiance quant à la pérénnité de cette dépendance
autant en terme de qualité du code, et de la maintenance.  Ainsi
certain framework bien que correspondant au critère technique seront
négligé du fait de leur immaturité ou de l'instabilité de leur
gouvernance.

La solution proposé devra être validé étape après étape par la
communauté au moyen de discussions sur la liste de diffusion
\footnote{\href{mailto:dev@ofbiz.apache.org}{\nolinkurl{dev@ofbiz.apache.org}}}
et de revue de codes sur le gestionnaire de ticket
JIRA\footnote{\url{https://issues.apache.org/jira/projects/OFBIZ}}. C'est
en cela que le mode de développement de ce stage est agile dans la
mesure les remarques emanant de la communauté peuvent arrivé à tout
moment et donc amené un changement de direction ou de besoins.

Le code écrit devra être soumis à la licence Apache 2.0 avec une
signature d'un accord de license de
contributeur\footnote{\url{https://www.apache.org/licenses/icla.pdf}} (ICLA)
permettant d'apporter des garanties en terme de « propriété
intellectuelle ».

\section{Propositions passées}

Cela fait plusieurs années que l'intégration d'un moyen d'accéder aux
services et entitées au moyen d'une API HTTP de style REST est en
discussion au sein de la communauté des développeurs de OFBiz.  En
effet c'est en 2011 qu'Adrian Crum proposa un premier
prototype\footnote{\url{https://issues.apache.org/jira/browse/OFBIZ-4274}}. La
première idée était de permettre de faire du \emph{CRUD} sur les
entités aux travers des méthodes HTTP.  Il a été ensuite question de
permettre d'appeler des services et de faire correspondre le
dictionnaire d'entrée et de sorties du service avec les
représentations JSON et XML.  Cependant la conversion des codes
d'erreurs d'appel de services vers des codes d'erreur HTTP semble
difficilement automatisable.  En effet les types d'errreur de services
sont \emph{Success}, \emph{Fail}, et \emph{Error}.  Lorsque l'appel
d'un service échoue du fait de la non-authentification de l'appelant
le code de retour est \emph{Fail} ce qui implique qu'il ne peut être
distinguer d'une erreur d'exécution et que donc il n'y a pas de moyen
de mapper l'échec d'authentification vers le code d'erreur 401 et

\section{Proposition}

Actuellement OFBiz gère les requêtes HTTP grâce à une servlet Java
\cite{chan2017servlet} définit dans la classe \verb=controlServlet=.
Le traitement des requêtes HTTP considère les méthode \verb=GET= et
\verb=POST= sans disctinction.  La première voie explorée a été de
définir une servlet alternative à \verb=controlServlet=.  Cela avait
été fait dans l'idée de définir des définir le support des méthodes
HTTP et des templates d'URI au moyen de JAX-RS qui s'intègre bien avec
le mécanisme de Servlet. Il était également question dans ce contexte
de séparer les routes de l'API et les routes pointant vers les écrans.
OFBiz fournit déjà un routeur HTTP avec l'ensemble des routes définis
dans \verb=controller.xml= sans distinction de routes HTTP servant à
appeler un service et celle correspondant à un écran.  De ce fait il a
semblé pertinent d'adapté la grammaire XML du contrôleur plutôt que de
proposer une implémentation parallèle utilisant un paradigme de
définition de routes différents des habitudes des développeurs OFBiz.

Étant donné qu'il est hors de propos de déprécier le mécanisme de
routage actuel, un telle solution étrangère aurait amené de la
complexité accidentelle du fait des différentes options quand à
l'endroit ou définir une route HTTP.  Ainsi la solution qui a été
approfondi a été celle d'adapter la grammaire XML définit par le
schéma
\href{http://ofbiz.apache.org/dtds/site-conf.xsd}{\nolinkurl{site-conf.xsd}}.

Le choix a été fait de proposer une solution itérative plutôt que
d'adopter une approche holistique.  En s'inspirant du le modèle de
maturité de Richardson \cite{fowler2010richardson}, nous avons
considérer l'introduction de la notion de ressource et de support des
méthodes HTTP sans nous préoccuper de la problématique de
l'hypermédia.

\subsection{Modification du controlleur}

La modification du contrôleur a consisté d'une part a ajouté un
attribut \verb=method= à l'élément \verb=request-map= acceptant un nom
de méthode HTTP. Cet attribut est optionnel et sa valeur par défault
est la chaine vide. La sémantique associé à cet attribut est une
contrainte sur la résolution des requêtes.  Ainsi dans l'exemple de la
figure \ref{fig:controlmodif} la route \verb=/example= n'est
accessible qu'au travers de la méthode \verb=GET= et la route
\verb=/example2= n'est accessible qu'au travers de la méthode
\verb=POST=.  Le comportement par défault est de gérer l'ensemble des
méthodes HTTP.  Cela reste donc compatible avec l'implémentation
précédente sans impliquer de changement majeur dans le schéma XSD.

\begin{figure}
  \begin{lstlisting}[language=xml]
<request-map uri="example" method="get">
   <security https="true" auth="true"/>
   <event type="java" path="ExamplesHandlers" invoke="getExamples"/>
   <response name="success" type="view" value="..."/>
   <response name="error" type="view" value="..."/>
</request-map>

<request-map uri="example2" method="post">
   <security https="true" auth="true"/>
   <event type="java" path="ExamplesHandlers" invoke="postExamples"/>
   <response name="success" type="view" value="..."/>
   <response name="error" type="view" value="..."/>
</request-map>
  \end{lstlisting}
  \caption{Modification du contrôleur}
  \label{fig:controlmodif}
\end{figure}

Le deuxième travail réalisé à été de supporter les templates d'URI.
En effet lorsque l'on modélise des ressources cela implique
généralement de modéliser des collections.  On a donc envie de pouvoir
identifier de manière générique un élement de cette collection.  Les
templates d'URI permettent de faire cela.  Afin d'avoir une
implémentation robuste, nous avons fait le choix de réutiliser la
classe \verb=URITemplate= développé par Apache CXF.  Cela nous permet
d'entamer la transition d'un modèle RPC vers un modèle ressources
comme le montre l'exemple de la figure \ref{fig:urit} qui introduit la
resources \emph{geos} en lieu et place de l'ensemble de noms
correspondant à des appels de services.

\begin{figure}
  \begin{lstlisting}[language=xml]
<request-map uri="LookupGeo">...</request-map>
<request-map uri="createGeo">...</request-map>
<request-map uri="updateGeo">...</request-map>
<request-map uri="deleteGeo">...</request-map>

<request-map uri="geos" method="get">...</request-map>
<request-map uri="geos" method="post">...</request-map>
<request-map uri="geos/{id}" method="update">...</request-map>
<request-map uri="geos/{id}" method="delete">...</request-map>
  \end{lstlisting}
\caption{Conversion des identitifiants géographiques}
\label{fig:urit}
\end{figure}

\subsection{Rendu JSON}

En complément de ce travail sur le routage, un travail sur le rendu
des ressources au moyen de représentations JSON a été amorté.  Cela a
été fait en utilisant l'abstraction du moteur d'écrans.  Concrétement
nous avons implémenté un visiteur \cite{gamma1993design} permettant de
parcourir le modèle des écrans et widgets pour constuire un Objet
JSON.

\section{Difficultés}

D'un point de vue extérieur l'ensemble des fonctionnalités développée
au cours des 3/4 mois consacré au développement peut semblé restreint.
Cependant quelques explications concernant le contexte permettent de
mieux mesurer les enjeux de la tâche.  En effet le framework OFBiz est
un framework ayant accumulé de la dette technique et impliquant
beaucoup de complexité accidentelle. Par exemple le moteur d'écrans a
accumulé des extensions de son modèle sans architecture adapté
entrainant une grande difficulté de raisonnement autour de ce modèle.

En ce qui concerne mon travail au niveau du contrôleur, un grand frein
dans le développement était le fait que cela devait s'intégrer dans
une méthode de plus 800 lignes remplit de mutations, de comparaison à
null, et avec des chemins d'exécution complexe. Cela a donc impliqué
un travail important de réusinage faisant usage des nouvelles
possibilité offertes par Java 8 que sont l'API des streams et l'ajout
des lambda.

Un autre point important est le rapport à la communauté OFBiz.  En
effet le travail communautaire impose une temporalité particulière, et
les soumission de patches peuvent être plus compliquée que dans
d'autre contexte lorsqu'il faut convaincre la personne en mesure de
committé son travail de l'intérêt du code proposé.  Cette lenteur et
prudence est justifié par le fait que tout modification de code peut
impacter en premier lieu les utilisateurs, mais aussi les responsables
du projet qui devront inévitablement maintenir le code ajouté.

\chapter{Conclusion}

\clearpage
\bibliographystyle{plain}
\bibliography{biblio}

%% Liens donnés par Nicolas
%% https://www.infoq.com/articles/rest-introduction
%% http://apidoc.adility.com/submission-api
%% http://blog.pilotsystems.net/2012/septembre/les-api-rest

\end{document}
