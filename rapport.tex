\documentclass[a4paper, 11pt]{report}
\usepackage[margin=2.5cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{tikz-uml}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{caption}
\DeclareCaptionLabelFormat{cont}{#1~#2\alph{ContinuedFloat}}
\captionsetup[ContinuedFloat]{labelformat=cont}
\usepackage{tikz}
\usetikzlibrary{decorations,arrows,shapes,automata}
\usepackage{listings}
\lstset {basicstyle=\footnotesize, tabsize=2}
\tikzumlset{fill class=black!5, fill component=white, fill usecase=black!10}

\title{Implémentation d'une API HTTP de style REST pour Apache OFBiz}

\author{Mathieu Lirzin}

\date{30 août 2018}

\begin{document}

\maketitle

\begin{abstract}
  Ceci est un rapport de stage de fin d'études effectué au sein de la
  société Néréide. Ce stage a consisté à mettre en place une API HTTP
  basée sur le style d'architecture REST pour les échanges entre
  différents composants logiciels du framework Apache OFBiz pour
  réorienté l'Architecture Orienté Service (SOA) de ce framework.
\end{abstract}

\tableofcontents

\chapter*{Introduction}

Ceci est un rapport de stage de fin d'études de Master 2 Informatique
de l'Université de Bordeaux effectué au sein de la société Néréide
pendant une durée de 5 mois entre le 2 Avril et le 30 Août 2018.

Le sujet de ce stage a consisté à mettre en place une API HTTP basée
sur le style d'architecture REST pour les échanges entre différents
composants logiciels du framework Apache OFBiz.  Cela a consisté dans
une première phase à réaliser un état de l'art de l'utilisation de ce
style architectural, puis à étudier les principes d'architectures
orientées services (SOA) utilisés dans le framework Apache OFBiz.
dans une deuxième phase l'API HTTP basée sur le style REST a été
implementée au sein du framework Apache OFBiz en suivant les principes
SOA.  Ces améliorations ont été réalisées en interaction avec la
communauté Apache OFBiz afin de permettre leurs intégration dans les
prochaines versions.

Nous allons dans un premier temps faire une présentation la société
d'accueil. Dans un deuxième temps nous présenterons le framework sur
lequel s'est basé le travail effectué lors de ce stage qui sera lui
présenté dans un troisième temps.

\chapter{Présentation de l'entreprise}

Néréide est une société de service en logiciel libre fondée en 2004
spécialisée dans l'intégration du progiciel de gestion intégré Apache
OFBiz.  Il s'agit d'une société coopérative et participative (SCOP)
dont le siège social est situé à Tours.  Les activités de la société
se décompose en différents axes:

\begin{description}
\item[Dévéloppement spécifique] L'intégration du framework OFBiz
  implique généralement des développement spécifique pour s'adapter au
  différents composants du système d'information existant.
\item[Maintenance et support applicatif (TMA)] Prestation de support
  et de maintenance corrective et/ou evolutive pour les développement
  spécifiques précédemment fait
\item[Administration système] mettre en place un élément système, un
  réseau, intégrer et migrer des composant systèmes.
\end{description}

Néréide s'appuie sur le réseau Libre Entreprise dont elle fait partie
pour proposer des services tels que l'hébergement, de formation.
L'équipe est actuellement composée de 11 personnes, ayant pour point
commun une expertise fonctionnelle sur OFBiz.

\chapter{Présentation de OFBiz}

Apache \emph{Open For Business} (OFBiz) est un framework Web ayant
pour but de faciliter la construction de progiciels de gestion
intégré.  Cet objectif est réalisé au moyen d'un modèle de donnée
générique et d'un ensemble de modules dédiés à des tâches commune à la
plupart des entreprises, telles que la comptabilité, la facturation,
ou la gestion des stocks.

OFBiz a été créé en 2001 par David E. Jones et Andy Zeneski dans
l'idée de développer une solution commune aux différentes
problématiques rencontrées par les entreprises en utilisant un modèle
de développement en logiciel libre. En janvier 2006 OFBiz a été accepté
dans l'incubateur de la fondation Apache avant d'être accepté en tant
que projet a part entière en décembre 2006.

\section{Architecture générale}

Techniquement OFBiz est basé sur la plateforme Java et sur
l'utilisation de \emph{langage spécifique au domaine} (DSL) basé sur
des grammaires XML.  Concenant le coeur du framework, les
communications HTTP sont gérés par des Servlets \cite{Chan2017servlet}
et les communications avec les base de données se font au moyen de
l'API Java JDBC.  Au dessus de cela la déclaration des routes HTTP,
des écrans et des services se fait dans des fichiers XML faisant
référence à des implementations de services généralement en Java et
Groovy.  Les écrans sont quant à eux basés sur Freemarker qui est un
langage de templating.

%% \begin{figure}
%%   \centering
%%   \begin{tikzpicture}
%%   \end{tikzpicture}
%%   \caption{Architecture globale de OFBiz}
%% \end{figure}

\begin{figure}
  \centering
  \begin{tikzpicture}
    \umlbasiccomponent[y=1.5]{Plugins}
    \umlbasiccomponent[x=5,y=3]{Applications}
    \umlbasiccomponent[x=5]{Framework}
    %% \umlassemblyconnector[interface=Fcs,
    %%   geometry=-|]{Applications}{Framework}
    \umldep{Applications}{Framework}
    \umldep[geometry=-|-]{Plugins}{Applications}
    \umldep[geometry=-|-]{Plugins}{Framework}
  \end{tikzpicture}
  \caption{Dépendances entre les méta-composants}
  \label{fig:compdep}
\end{figure}

OFBiz est structuré en séparant le framework, les applications, et les
plugins.  Le framework fournit les méchanismes de communications
réseau et d'interfacage entre les différentes applications.  Les
plugins sont des applications spécifiques qui ont la spécificité de
dépendre des applications de base mais dont aucune application de base
ne dépend.  OFBiz est décomposé en plusieurs composants qui sont
regroupés en plusieurs catégories ou meta-composants. Ainsi les
composants fondamentaux définissant l'architecture d'OFBiz sont
contenus dans l'ensemble de composants \emph{Framework}.  Les
composants fonctionnels fondamentaux tels que la comptabilité, la
facturation, ou la gestions des stock sont regroupés dans l'ensemble
de composants \emph{Applications}.  Les composants spécifiques sont
eux mis dans la catégories \emph{Plugins}. Un point important dans la
relation entre ces différents composants est qu'il est important que
les relations de dépendances entre les méta composants soient
respectés comme cela est représenté sur la figure \ref{fig:compdep}.
Cela permet entre autre de développer les plugins dans un dépôt
externe.  Nous allons dans les sections suivantes détailler le contenu
et l'architecture des deux méta-composants \emph{Framework} et
\emph{Applications}.

\section{Le framework}

Le framework fournit les éléments de base définissant l'architecture
d'OFBiz ainsi que des outils de maintenance permettant d'intéragir
avec une instance d'OFBiz en cours d'exécution. Nous présentons ici
les concepts et élements fondamentaux pour comprendre l'organisation
de l'architecture du framework.

\subsection{Container}

\begin{figure}
  \centering
  \begin{tikzpicture}
    \umlinterface[]{Container}{}{
      \umlvirt{+ init(cmds : List<StartupCommand>, name : String,
        config : String) : void} \\
      \umlvirt{+ start() : void} \\
      \umlvirt{+ stop() : void} \\
      \umlvirt{+ getName() : String}
    }

    \umlclass[x=5,y=-4]{StartupCommand}{
      - name : String \\
      - properties : Map<String, String>
    }{
      \umlvirt{+ getName() : String} \\
      \umlvirt{+ getProperties() : Map<String, String>}
    }

    \umldep[geometry=|-]{Container}{StartupCommand}

  \end{tikzpicture}
  \caption{Définition du type container}
  \label{fig:containertype}
\end{figure}

Un container est l'élément de plus bas niveau que définit OFBiz.  Un
container est processus tournant en tâche de fond pouvant être
initialisé, démarré et arreté.  Concrètement cela est représenté par
l'interface \verb=Container= représenté sur la figure
\ref{fig:containertype}. OFBiz ne définit par défault qu'un seul
container dans un fichier \verb=ofbiz-container.xml= et il est
possible pour chacun des composants de définir leur propres
containers.  L'intérêt de cette abstraction est de permettre de lié
l'exécution un daemon externe au lancement de OFBiz. Ainsi le plugin
OFBiz Camel définit un container pour le runtime de Apache Camel en
charge de faire communiquer les différents points de sorties.  Un
container est paramétré par un ensemble de phases décrites dans
l'attribut \verb=loaders= du container.  Cet attribut détermine à
quelles phases ce container doit être démarré.  Les 3 phases suivantes
sont définis:
\begin{description}
\item[main] la phase d'exécution de ofbiz
\item[load-data] la phase de chargement des données dans la base de
  données
\item[test] la phase de lancement des tests d'intégrations
\end{description}

\subsection{Composants}

Un composant est une abstraction permettant de séparer les différentes
fonctionnalités de OFBiz. Un composant est une agglomération de
containers, entités, services, écrans, et applications Web.  Un
composant est définit au moyen d'un structure XML stocké dans le
fichier \verb=ofbiz-component.xml= qui est à la racine du répertoire
contenant l'ensemble des définitions qu'il contient.  La figure
\ref{fig:ofbizcomponent} montre l'exemple du composant \emph{Webtools}
qui fait référence à deux fichiers contenant des définitions
d'entités, à un fichier de service et à une application Web.

\begin{figure}
  \begin{lstlisting}[language=xml]
<ofbiz-component name="webtools"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://ofbiz.apache.org/dtds/ofbiz-component.xsd">
  <resource-loader name="main" type="component"/>
  <classpath type="dir" location="config"/>

  <entity-resource type="data" reader-name="seed" loader="main"
                   location="data/WebtoolsSecurityPermissionSeedData.xml"/>
  <entity-resource type="data" reader-name="demo" loader="main"
                   location="data/WebtoolsSecurityGroupDemoData.xml"/>
  <service-resource type="model" loader="main" location="servicedef/services.xml"/>
  <webapp name="webtools"
          title="WebTools"
          menu-name="secondary"
          server="default-server"
          location="webapp/webtools"
          base-permission="OFBTOOLS,WEBTOOLS"
          mount-point="/webtools"/>
</ofbiz-component>
  \end{lstlisting}
  \caption{Définition du composant Webtools}
  \label{fig:ofbizcomponent}
\end{figure}

l'élément \verb=resource-loader= définit de quelle manière ce
composant sera chargé par OFBiz. L'élément \verb=classpath= définit le
chemin vers des ressources tel que les traductions de label contenu
dans le dossier pointé par l'attribut \verb=location=.  Concernant les
éléments \verb=entity-resource= il est possible d'avoir des types
"model" ou "data". La différence étant que "model" contient des
définitions d'entités et "data" contient des exemples de données qui
serve à fournir des données d'exemples.

\subsection{Applications Web}

Chaque composant peut définir des applications web qui sont une
extension du modèle des servlets sont monté dans un serveur
d'applications partagé par tous les composants. Généralement un
composant possède une application mais il est possible d'en avoir
plusieurs dans un même composant.  Dans le cas du méta-composant
\emph{Framework} il n'y a qu'une seule application Web qui est associé
au composant \emph{Webtools}. Les composants contenu dans
\emph{Applications} on presque tous au moins une application Web
associé.  Il est a noté que bien qu'OFBiz soit basé sur l'architecture
des servlets il n'est pas possible de déployer les différentes
applications Web dans un serveur d'application externe dans la mesure
où le processus de compilation d'OFBiz embarque dans un même JAR
l'ensemble des applications web ainsi que le serveur d'application.
Classiquement la définitions des routes pour les servlet se fait dans
un fichier \verb=web.xml=.  Dans le cas d'OFBiz ce routage est délégué
à un fichier \verb=controller.xml= associant les différents
traitements à des routes HTTP ainsi que les écrans qui seront
retournée suite à ces traitements. Seules les requêtes \verb=POST= et
\verb=GET= sont traités du fait que le client est uniquement prévu
pour être un navigateur.  Il n'y a de différences dans le traitement
des requêtes.  Peu importe la méthode choisi cela à pour effet
d'appeler l'evénement associé.  La figure \ref{fig:controller}
présente une partie du fichier \verb=controller.xml= du composant
\emph{Webtools}.

\begin{figure}
  \begin{lstlisting}[language=xml]
<site-conf xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xmlns="http://ofbiz.apache.org/Site-Conf"
	   xsi:schemaLocation="http://ofbiz.apache.org/Site-Conf...">
  <include location="component://common/webcommon/WEB-INF/common-controller.xml"/>
  <include location="component://common/webcommon/WEB-INF/portal-controller.xml"/>
  <include location="component://common/webcommon/WEB-INF/security-controller.xml"/>
  <include location="component://common/webcommon/WEB-INF/tempexpr-controller.xml"/>
  <description>WebTools Site Configuration File</description>
  <handler name="ftl" type="view"
           class="org.apache.ofbiz.webapp.ftl.FreeMarkerViewHandler"/>
  ...
  <request-map uri="ping">
    <event type="service" invoke="ping"/>
    <response name="error" type="view" value="ping"/>
    <response name="success" type="view" value="ping"/>
  </request-map>
  ...
  <view-map name="ping" type="ftl" page="component://webtools/template/Ping.ftl"/>
  ...
</site-conf>
  \end{lstlisting}
  \caption{Définition du contrôleur de Webtools}
  \label{fig:controller}
\end{figure}

\subsection{Moteur d'entités}

\begin{figure}
  \centering
  \begin{tikzpicture}
    \umlclass[]{GenericEntity}{
      - internalDelegator : Delegator
    }{}

    \umlsimpleclass[x=6]{Delegator}

    \umlclass[y=-4]{GenericValue}{
    }{
      \umlvirt{+ store() : void} \\
      \umlvirt{+ remove() : void} \\
      \umlvirt{+ refresh() : void} \\
      \umlvirt{+ refreshFromCache() : void} \\
      \umlvirt{+ getRelated(field: String) : List<GenericValue>} \\
      ...
    }

    \umlinherit[geometry=-|]{GenericValue}{GenericEntity}
    \umldep{GenericEntity}{Delegator}

  \end{tikzpicture}
  \caption{Définition du type valeur générique}
  \label{fig:genericvalue}
\end{figure}

Un point crucial d'un framework comme OFBiz est l'accès aux bases de
données.  Pour cela OFBiz possède un moteur d'entités pour communiquer
à les système de base de données relationnelles.  Ce moteur d'entités
permet à la fois de définir des schémas adaptés au différent SGBD au
moyen d'un modèle entité-relation avec des types de données génériques
associé à des types concrets adaptés à l'implémnentation cible. Un
deuxième aspect est la construction de requêtes SQL au sein des
programmes Java et Groovy au moyen d'un DSL utilisant le pattern
\emph{builder} \cite{gamma1993design}. Lors que ces requêtes sont
envoyés, leur résultat retourne des valeurs « actives » c'est à dire
gardant une référence sur la connexion à la base de données pour
pouvoir sauvegarder en base les modifications faites en sur ces
objets.  Cela correspond au pattern architectural \emph{active record}
\cite{fowler2002patterns}.  La figure \ref{fig:genericvalue}
représente les relations entre ces valeurs « actives » représenté par
la classe \verb=GenericValue= et la connexion à la base de données
représenté par la classe \verb=Delegator=.

\subsection{Moteur de services}

\begin{figure}
  \centering
  \begin{tikzpicture}
    \umlinterface[]{GenericEngine}{}{
      \umlvirt{+ runSync(name : String, m : ModelService,
        context : Map)} \\
      \umlvirt{+ runSyncIgnore(name : String, m : ModelService,
        context : Map)} \\
      \umlvirt{+ runAsync(name : String, m : ModelService,
        context : Map, r : GenericRequester,
        persist : boolean)} \\
      \umlvirt{+ runAsync(localName : String, m : ModelService,
        context : Map, persist : boolean)} \\
      \umlvirt{+ sendCallBacks(m : ModelService,
        context : Map, mode : int)} \\
      \umlvirt{+ sendCallBacks(m : ModelService,
        context : Map, result : Map,
        mode : int)} \\
      \umlvirt{+ sendCallBacks(m : ModelService,
        context : Map, t : Throwable, mode : int)} \\
    }
  \end{tikzpicture}
  \caption{Définition du type service}
  \label{fig:serviceengine}
\end{figure}

OFBiz est basé sur une architecture orientée service (SOA).  La notion
de moteur de service est définit par l'interface Java
\verb=GenericEngine= représenté sur la figure \ref{fig:serviceengine}.
Un service peut être appelé en lui passant un contexte en entrée, il
renvoie alors une \emph{Map} permettant de récupérer le type de retour
conventionnellement nommé "success", "error", ou "fail" ainsi que les
données renvoyées par le service.  Il est possible d'exécuter un
service soit de manière synchrone avec les méthodes \verb=runSync= ou
\verb=runSyncIgnore= soit de manière asynchrone avec les méthodes
\verb=runAsync=.  Les méthodes \verb=sendCallBacks= permettent
d'exécuter des traitements associé de manière \emph{ad hoc} à un
service. Ces méthodes sont considéré comme obsolètes et on été
remplacée par l'utilisation des \emph{Event Condition Access} (ECA)
décrit plutard. Dans la pratique les services sont exécutés la plupart
du temps de manière synchrone.  Un service à accès au moteur d'entités
pour manipulés les données et au moteur de services pour appeler
d'autres services.

Il existe plusieurs implémentations de cette interface parmi
lesquelles on trouve les classes \texttt{EntityAutoEngine},
\texttt{StandardJavaEngine}, et \texttt{GroovyEngine}.  Cela permet
d'écrire des services dans différents langages de programmation ou
même par des services distant ce qui est le cas du moteur de services
\verb=XMLRPCClientEngine=. Il est possible pour les plugins de fournir
leur propre implémentation de services à fin de faire communiquer
OFBiz avec d'autres composants logiciels.

Les ECA permettent d'exécuter des traitement à différentes phases de
l'exécution d'un service.  Les différentes phases existantes sont
"auth", "in-validate", "out-validate", "invoke", "commit", et
"return".


\subsection{Moteur d'écrans}

\section{Les applications}

La catégorie applications se composent des composants suivant:
accounting, commonext, content, datamodel, humanres, manufacturing,
marketing, order, party, product, securityext, workeffort.

\chapter{État de l'art}

\section{Representational State Tranfer}

\emph{Representational State Transfer} (REST) est un style
architectural ayant émergé au début de l'année 1995.  Il s'agit d'un
modèle idéalisé décrivant comment le \emph{Web} devrait fonctionner
\cite{fielding2002principled}.  Il a été affiné pendant 5 ans jusqu'à
être décrit en détails par Roy Fielding dans sa thèse de doctorat
\cite{fielding2000architectural} en 2000.  Un style architectural est
un ensemble de contraintes placées sur une architecture logicielle
c'est à dire une abstraction décrivant les composants, les
connecteurs, ainsi que les données présents au sein d'un système
\cite{perry1992foundations}.

\begin{figure}
  \centering
  \resizebox {0.8\columnwidth} {!} {
  \begin{tikzpicture}
    \tikzstyle{as}= [draw,rectangle,rounded corners=3pt]
    \tikzstyle{asc}= [draw,rectangle,rounded corners=3pt, fill=black!10]
    \tikzstyle{cst}= [right,scale=0.7]
    \node[as] (o) at (0, 10) [circle,fill] {};
    \node[as] (RR) at (-5, 8) {RR};
    \node[asc] (cache) at (-5, 6) {\$};

    \node[asc] (CS) at (-3, 8) {CS};
    \node[asc] (CSS) at (-3, 6) {CSS};
    \node[as] (CcacheSS) at (-3, 4) {C\$SS};

    \node[asc] (LS) at (0, 8) {LS};
    \node[as] (LCS) at (0, 6) {LCS};
    \node[as] (LCcacheSS) at (0, 4)  {LC\$SS};

    \node[as] (VM) at (2.8, 8) {VM};
    \node[asc] (COD) at (2.8, 6) {COD};
    \node[as] (LCODCcacheSS) at (2.8, 4) {LCODC\$SS};

    \node[asc] (U) at (5, 8)  {U};
    \node[as] (REST) at (5, 4) {REST};

    \draw[->] (o) edge [bend right=15] node[cst, left]{replicated} (RR);
    \draw[->] (o) edge [bend right=10] node[cst]{separated} (CS);
    \draw[->] (o) edge node[cst]{layered} (LS);
    \draw[->] (o) edge [bend left=2] node[cst]{programmable} (VM);
    \draw[->] (o) edge [bend left=15] node[cst,yshift=10]{uniform interface} (U);
    \draw[->] (RR) edge node[cst]{on-demand} (cache);
    \draw[->] (cache) edge node[cst, left]{cacheable} (CcacheSS);
    \draw[->] (CS) edge node[cst]{stateless} (CSS);
    \draw[->] (CSS) edge node[cst]{reliable} (CcacheSS);
    \draw[->] (LS) edge (LCS);
    \draw[->] (LCS) edge node[cst]{shared} (LCcacheSS);
    \draw[->] (VM) edge (COD);
    \draw[->] (COD) edge node[cst]{extensible} (LCODCcacheSS);
    \draw[->] (U) edge node[cst, text width=3cm, left,xshift=25, yshift=30]{simple visible reusable} (REST);
    \draw[->] (CS.east) edge node[cst, sloped, text
      width=2cm, centered]{intermediate processing} (LCS);
    \draw[->] (CS.east) edge[bend left=15, pos=0.75] node[cst]{mobile} (COD);
    \draw[->] (CcacheSS) edge node[cst,centered, yshift=10]{scalable} (LCcacheSS);
    \draw[->] (LCcacheSS) edge node[cst,left, text width=0.5cm]{multi-org} (LCODCcacheSS);
    \draw[->] (LCODCcacheSS) edge  (REST);
  \end{tikzpicture}
}
  \caption{Dérivation du style architectural REST}
\end{figure}

REST est composé des 6 contraintes suivantes:

\begin{description}
\item[Client-Serveur (CS)] Cette contrainte permet la séparation des
  préoccupations entre le(s) serveur(s) et le(s) client(s).
  Typiquement il est important de ne pas lier une interface
  utilisateur aux services rendus par le serveur, pour permettre la
  réutilisabilité des services et la variété des interfaces
  utilisateurs.  Dans un contexte distribué cela permet au client et
  au serveur d'évoluer indépendamment.

\item[Serveur sans état (CSS)] Chaque requête envoyé par le client
  doit pouvoir être traitée de manière indépendante.  Cela impose de
  transmettre dans chacune des requêtes les données permettant
  d'authentifier le client.  Cela rend l'architecture robuste dans la
  mesure où cela limite les contraintes d'ordre dans l'envoi de
  messages.  Dans un contexte avec plusieurs serveurs cela permet de
  passer simplement à l'échelle.  Cependant cette redondance
  d'informations entre les requêtes impose un surcout de transfert de
  données.

\item [Possible mise en cache (\$)] Pour contrecarrer ce sur-coût,
  REST impose de pouvoir spécifier dans les messages si les
  informations qu'ils contiennent peuvent être garder en cache et
  ainsi limiter le nombre de messages transmis sur le réseau.

\item[Interface uniforme (U)] Cette contrainte est centrale à REST et
  consiste dans la manipulation des ressources uniquement par leur(s)
  représentation(s), l'utilisation de messages auto-descriptif, et
  l'utilisation de \emph{l'hypermédia comme moteur de l'état de
    l'application}\footnote{plus connu sous sa forme anglaise
    \emph{Hypermedia As The Engine Of Application State} (HATEOAS)}

\item[En couches (LS)] Cette contrainte permet de limiter la
  complexité de l'architecture en revanche elle a l'inconvénient
  d'avoir un surcôut en terme d'exécution.

\item[Code à la demande (COD)] Ceci est une contrainte optionelle
  permettant au serveur d'étendre les fonctionnalités du client.
\end{description}

\section{Architecture Web}

L'architecture Web est une instance du style architectural REST.  En
fait REST a été conceptualisé conjointement au World Wide Web pour
permettre de décrire de manière abstraite les enjeux d'un tel système.
Nous présentons ici les différents composants que sont le protocole
HTTP, les URI, et les formats de données tels HTML, XML, et JSON.

\subsection{Protocole HTTP}

Le protocole \emph{Hypertext Transfer Protocol} (HTTP) est un
protocole texte utilisé sur le Web pour transmettre les ressources
HTML, CSS, Javascript.  Ce protocole suit les contraintes définies par
le style architectural REST.  Il a un rôle particulier dans
l'architecture \emph{Web} puisqu'il sert à la fois à la communications
entre les composants \emph{Web} et est l'unique protocole intégrant la
notion de représentations de ressources.  L'accès aux ressources se
fait au moyen de 4 méthodes principales \verb=GET=, \verb=POST=,
\verb=HEAD=, \verb=DELETE= mais également de 5 autres méthodes moins
courantes \verb=OPTIONS=, \verb=CONNECT=, \verb=TRACE=, \verb=PUT=,
\verb=PATCH=.

\begin{verbatim}
GET /hello.txt HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11
\end{verbatim}

La standardisation des types de méthodes permettent à des clients
génériques de faire des suppositions sur le propriétés de ces
méthodes.  Par exemple de la méthode \verb=GET= est nullpotent c'est à
dire qu'elle ne doit pas modifier l'état des ressources, et la méthode
\verb=POST= est idempotent c'est à dire que la réception de plusieurs
message ne doit produire qu'une seule action.

l'URI ne doit pas être l'API mais la représentation des données
identifié par cette URI.  En pratique cela qu'il faut privélégier la
récupération d'URL dans les payloads plutôt que concaténer des chaînes
de caractères qui est un signe que l'URL est l'API.
%% Comment traiter le versioning?

Les méchanismes de cache à différents points du réseau
\cite{fielding1999hypertext}.

\subsection{Uniform Resource Identifier}

Les \emph{Uniform Resource Identifiers} (URI) servent à nommer toute
sorte des ressources (document, images, service, ...)
\cite{masinter2005uniform}.  Les URI ne sont pas des emplacements et
donc ne sont pas liées à un serveur spécifique ce qui permet
d'utiliser des proxies.  Comme montré par la <<rep-res,figure 2>> les
URI permettent uniquement d'accéder à des représentations et non
directement à des ressources.  Cette distinction permet une forme de
polymorphisme en associant plusieurs représentations à une même
ressource.  En pratique l'accès à ces représentations se fait au moyen
du header \verb=Accept= présent dans la requête émise vers une URI,
qui dispatche alors vers la représentation la plus adaptée.

\begin{center}
  \begin{tikzpicture}
    \tikzstyle{n}= [draw,rectangle,rounded corners=3pt]
    \node[n, circle] (c) at (0, 0) {Client};
    \node[n] (rep) at (4, 0) {Représentation};
    \node[n] (res) at (9, 0) {Ressource};
    \draw[->] (c) edge [bend left] node [above] {envoit} (rep);
    \draw[->] (rep) edge [bend left] node [below] {recoit} (c);
    \draw[<->] (rep) edge node [above] {met à jour} (res);
  \end{tikzpicture}
\end{center}

Les URI peuvent à la fois référencer des ressources statiques ou des
ressources dynamiques.  Une ressource $R$ est un fonction $M_r(t)$
associant à un temps $t$ une entité ou valeurs.  L'ensemble des
entités ou valeurs appartenant au codomaine sont équivalentes en terme
de leur sémantique.  Même si ces ressources pointent sur la même
valeur il s'agit bien de 2 ressources distinctes.  Ce qui identifie
une ressource c'est la sémantique associé à son URI.

\subsection{Formats de données}

Lors d'une requête, il est possible pour le client de spécifier le
type contenu souhaité au moyen du header \verb=Accept= cependant il
faut que le serveur recevant cette requête soit en mesure de fournir
le format de donnée souhaité.  Dans la pratique les formats XML est
JSON sont les plus courant pour la transmission de données
structurées.

\subsection{Hypermédia}

La notion d'\emph{hypermédia} est cruciale dans la réalisation d'une
API RESTful bien qu'elle soit trop souvent négligé.  Cette notion est
une extension du contexte d'\emph{hypertext} au formats d'image, de
son, et de vidéos.  Il désigne un réseau d'information accessible de
manière non-linéaire et interactive au moyen de liens.
%% Hypermedia is defined by the presence of application control information embedded within, or as a layer above , the presentation of information  <<modern-web-archi>>.

Pour satisfaire la contraintes d'interface uniforme de REST, Il est
nécessaire d'implémenter l'hypermédia pour rendre les services
découvrables. Pour cela il a été proposé de combiner la méthode
\verb=OPTIONS= pour décrire les actions possibles sur une ressource au
moyen du header HTTP \verb=Allow= listant l'ensemble des Méthodes
supportées avec des URIs dans le corps de la réponses.

\begin{verbatim}
$ curl -i -X OPTIONS http://example.com/resources/1
HTTP/1.1 200 OK
Allow: GET, HEAD, POST, DELETE, [...]
Content-Length: 0
\end{verbatim}

\subsection{Bénéfices}

Dans le contexte du \emph{Web} l'hypermédia a été choisi pour sa
simplicité et généricité.  Cela a été fait dans l'objectif de rendre
la participation au \emph{Web} accessible au plus grand nombre.
L'hypermedia permet également de stocker les différentes informations
liées sur des serveurs différents et permet donc au \emph{Web} d'être
distribué.

Découvrabilité, faible couplage, mise à jour simplifié.

\subsection{Problèmes récurrents}

- Accès aux ressources par concaténation de chaines de caractères

\section{Implementations existantes}

En parallèle de cette discussion théorique et sur le language
spécifique à utiliser, il a été également question d'utiliser certains
framework pour accomplir cette tâche. Parmi ces frameworks ont été
cité:

\begin{itemize}
\item JAX-RS
\item Vert.x
\item Apache Juneau
\item Swagger.IO
\end{itemize}

\subsection{JAX-RS}

\emph{JAX-RS} est une API java permettant de créer des services Web «
RESTful » \cite{pericas2013jax}. Cette spécification est intégrée dans
\emph{JavaEE} et possède plusieurs implémentations dont Jersey qui est
l'implémentation de référence, RESTeasy, Restlet, et Apache CXF.
L'utilisation de Jersey est impossible du fait de l'incompatibilité de
sa license avec celle d'OFBiz.  Du fait de son intégration dans la
communauté Apache, CXF semble être une implémentation adapté à une
utilisation dans OFBiz.  L'avantage de cette solution est une
intégration et adoption forte dans l'univers JavaEE.  Du fait qu'OFBiz
est déjà couplé au JDK ce choix ne présente pas un grand risque.

Cette spécification utilise un système d'annotations comprenant les
annotations \verb=@Path=, \verb=@GET=, \verb=@POST=, \verb=@Produces=,
\verb=@Consumes= permettant de définir les méthodes à appeler pour une
route et une méthode données.

\subsection{Vert.x}

\emph{Vert.x} est un framework permettant de créer des API Web
Asynchrone.  Il s'inspire grandement de ce qui a été fait dans
\emph{Node.js} avec l'utilisation intensive de callback dans des
requêtes HTTP et les appels vers la base de données. Un point fort de
Vert.x est le fait que les traitements asynchrone soit bien intégré à
l'API. Cela permet d'écrire des traitements de requêtes de manière
relativment déclaratives grâce à des callbacks tout en ayant de bonnes
performances.  À la différence de JAX-RS, il n'y a pas de standard
pouvant donner une bonne confiance dans la pérénnité de Vert.x
d'autant que ce projet créé en 2011 reste relativement jeune.

\subsection{Apache Camel}

Apache camel est un framework implémentant un ensemble de patterns de
communications par envoi de messages décrits dans l'ouvrage «
Enterprise Integration Patterns » \cite{hohpe2003enterprise}.

Une solution intéressante proposé par ce framework et montré dans la
figure \ref{fig:restdsl} est la définition d'un langage spécifique REST
transposable à la fois en Java et en XML permettant de décrire les
routes et les handlers de traitement des types de requêtes associés à
ces routes.

\begin{figure}
  \ContinuedFloat*
  \begin{lstlisting}[language=java]
rest("/customers/")
  .get("/{id}").to("direct:customerDetail")
  .get("/{id}/orders").to("direct:customerOrders")
  .post("/neworder").to("direct:customerNewOrder");
  \end{lstlisting}
  \caption{REST DSL Java}
\end{figure}

\begin{figure}
  \ContinuedFloat
  \begin{lstlisting}[language=xml]
<rest path="/customers/">
  <get uri="/{id}">
    <to uri="direct:customerDetail"/>
  </get>
  <get uri="/{id}/orders">
    <to uri="direct:customerOrders"/>
  </get>
  <post uri="/neworder">
    <to uri="direct:customerNewOrder"/>
  </post>
</rest>
  \end{lstlisting}
  \caption{REST DSL XML}
  \label{fig:restdsl}
\end{figure}

\chapter{Réalisations}

\section{Analyse des besoins}

Afin de répondre au mieux aux besoins de ce stage, nous avons effectué
une analyse des besoins décomposer d'une part dans des besoins
fonctionnels pour décrire les fonctionnalités que devra avoir l'API
REST, et les besoins non-fonctionnels d'autre part pour décrire des
besoins qualitatifs ou des contraintes d'environnement ou de
développement.  Étant donné le mode de développement agile imposé par
le caractère communautaire du projet, cette analyse des besoins n'est
pas à voir comme un cahier des charges complet, mais comme une
description précise minimale de ce qui est attendu en terme de
développement et de manière de travailler.

\subsection{Besoins fonctionnels}

\begin{figure}
  \centering
  \begin{tikzpicture}
    \begin{umlsystem}[x=4]{API REST}
      \umlusecase[name=enti]{Manipuler entité}
      \umlusecase[name=hyper, y=-2, width=1.8cm]{Accèder à\\ une URI}
      \umlusecase[name=serv, y=-4]{Appeler service}
      \umlusecase[name=mrep, y=-5.5, width=2.5cm]{Recevoir/Envoyer\\représentation}
    \end{umlsystem}
    \umlactor[y=-4]{Client HTTP}
    \umlassoc{Client HTTP}{mrep}
    \umlassoc{Client HTTP}{hyper}
    \umlinclude{hyper}{enti}
    \umlinclude{hyper}{serv}
  \end{tikzpicture}
  \caption{Représentation des cas d'utilisation}
  \label{fig:needs}
\end{figure}

L'objectif de ce stage est de créer une API basée sur le protocole
HTTP et suivant le style architectural REST.  Actuellement les
traitements mis à disposition par OFBiz sont fournis au travers du
moteur de services accessible au moyen d'une interface HTTP de type
\emph{Remote Procedure Call} (RPC) et du moteur d'entités qui lui
n'est pas directement accessible par le réseau.  Le besoin premier
sous jacent à la création d'une API REST est de fournir une interface
orienté ressources aux moteurs de services et d'entités.  L'accès aux
ressources se fait au moyen d'une \emph{Uniform Resource Identifier}
(URI) à laquelle le client HTTP envoit une requête HTTP avec une
méthode (GET/POST/PUT...) adapté à la sémantique du traitement que le
client HTTP veut effectué.  Les requêtes utilisant les méthodes
POST/PUT incluent une charge utile prenant la forme d'une
représentation de ressource, permettant de créer ou modifier des
données sur le serveur.  Lors du traitement d'une requête par le
serveur, cela a pour effet d'appeler des services OFBiz et/ou de faire
des accès en base de données au moyen du moteur d'entités pour
manipuler des entités.  À partir de ces traitements le serveur envoit
ensuite une représentation de la ressource requêtée avec un code
d'erreur adapté à la sémantique du traitement effectué.  Ceci est
représenté de manière simplifié par le diagramme des cas d'utilisation
de la figure \ref{fig:needs}.

\subsection{Besoins non-fonctionnels}

La solution proposés devra s'intégrer dans le framework. Ainsi il est
important de peser tout ajout de dépendances.  En effet le fait de
dépendre d'un autre framework a l'avantage de ne pas avoir à
réimplémenter les services fournit par ce framework mais impose
d'avoir une forte confiance quant à la pérénnité de cette dépendance
autant en terme de qualité du code, et de la maintenance.  Ainsi
certain framework bien que correspondant au critère technique seront
négligé du fait de leur immaturité ou de l'instabilité de leur
gouvernance.

La solution proposé devra être validé étape après étape par la
communauté au moyen de discussions sur la liste de diffusion
\footnote{\href{mailto:dev@ofbiz.apache.org}{\nolinkurl{dev@ofbiz.apache.org}}}
et de revue de codes sur le gestionnaire de ticket
JIRA\footnote{\url{https://issues.apache.org/jira/projects/OFBIZ}}. C'est
en cela que le mode de développement de ce stage est agile dans la
mesure les remarques emanant de la communauté peuvent arrivé à tout
moment et donc amené un changement de direction ou de besoins.

Le code écrit devra être soumis à la licence Apache 2.0 avec une
signature d'un accord de license de
contributeur\footnote{\url{https://www.apache.org/licenses/icla.pdf}} (ICLA)
permettant d'apporter des garanties en terme de « propriété
intellectuelle ».

\section{Propositions passées}

Cela fait plusieurs années que l'intégration d'un moyen d'accéder aux
services et entitées au moyen d'une API HTTP de style REST est en
discussion au sein de la communauté des développeurs de OFBiz.  En
effet c'est en 2011 qu'Adrian Crum proposa un premier
prototype\footnote{\url{https://issues.apache.org/jira/browse/OFBIZ-4274}}. La
première idée était de permettre de faire du \emph{CRUD} sur les
entités aux travers des méthodes HTTP.  Il a été ensuite question de
permettre d'appeler des services et de faire correspondre le
dictionnaire d'entrée et de sorties du service avec les
représentations JSON et XML.  Cependant la conversion des codes
d'erreurs d'appel de services vers des codes d'erreur HTTP semble
difficilement automatisable.  En effet les types d'errreur de services
sont \emph{Success}, \emph{Fail}, et \emph{Error}.  Lorsque l'appel
d'un service échoue du fait de la non-authentification de l'appelant
le code de retour est \emph{Fail} ce qui implique qu'il ne peut être
distinguer d'une erreur d'exécution et que donc il n'y a pas de moyen
de mapper l'échec d'authentification vers le code d'erreur 401 et

\section{Proposition}

Actuellement OFBiz gère les requêtes HTTP grâce à une servlet Java
\cite{Chan2017servlet} définit dans la classe \verb=controlServlet=.
Le traitement des requêtes HTTP considère les méthode \verb=GET= et
\verb=POST= sans disctinction.  La première voie explorée a été de
définir une servlet alternative à \verb=controlServlet=.  Cela avait
été fait dans l'idée de définir des définir le support des méthodes
HTTP et des templates d'URI au moyen de JAX-RS qui s'intègre bien avec
le méchanisme de Servlet.  Il était également question de séparer les
routes de l'API et les routes pointant vers les écrans.

OFBiz fournit déjà un routeur HTTP avec l'ensemble des routes définis
dans \verb=controller.xml= sans distinction de routes HTTP servant à
appeler un service et celle correspondant à un écran.  De ce fait il a
semblé pertinent d'adapté la grammaire XML du controlleur plutôt que
de proposer une implémentation parallèle utilisant un paradigme de
définition de routes différents des habitudes des développeurs OFBiz.

Étant donné qu'il est hors de propos de déprécier le méchanisme de
routage actuel, un telle solution étrangère aurait amené les
développeurs a devoir se poser la question de l'endroit au définir une
route HTTP qu'il souhaiterait ajouté.  Ainsi la solution qui a été
approfondi a été celle d'adapter la grammaire XML définit par le
schéma
\href{http://ofbiz.apache.org/dtds/site-conf.xsd}{\nolinkurl{site-conf.xsd}}.

\subsection{Modification du controlleur}

\subsection{Rendu JSON}

\section{Difficultés}

Complexité du framework en particulier du moteur d'écran

dettes techniques importantes

overridden view URI

lenteur et prudence de la communauté

\section{Refactoring}

Découpage de la méthode \verb=doRequest=

Utilisation de l'API des streams et du type \verb=Optional=

\section{Futur développements}

\chapter{Conclusion}

\clearpage
\bibliographystyle{plain}
\bibliography{biblio}

%% Liens donnés par Nicolas
%% https://www.infoq.com/articles/rest-introduction
%% http://apidoc.adility.com/submission-api
%% http://blog.pilotsystems.net/2012/septembre/les-api-rest

\end{document}
