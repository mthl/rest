= Implémentation d’une API HTTP de style REST pour Apache OFBiz
Mathieu Lirzin <mathieu.lirzin@nereide.fr>

:numbered!:
== Introduction

Dans le cadre d'une amélioration du progiciel de gestion intégré Apache OFBiz nous souhaitons mettre en place une API HTTP basée sur le style d'architecture REST pour les échanges entre les différents
composants logiciels de type service. Il sera demandé au stagiaire dans un premier temps de réaliser un état de l'art de l'utilisation de ce style architectural, puis d'étudier les principes d'architectures orientées services (SOA) utilisés dans le framework Apache OFBiz.

Après cette phase d'analyse, l'API HTTP basée sur le style REST devra être implementée dans le framework Apache OFBiz en suivant les principes SOA.
Ces améliorations devront être réalisées en interaction avec les projets clients et la communauté Apache OFBiz afin de permettre leurs intégration dans le projet officiel.

:numbered:
== État de l'art

=== Representational State Transfer

_Representational State Transfer_ (REST) est un style architectural ayant émergé au début de l'année 1995.
Il s'agit d'un modèle idéalisé décrivant comment le _Web_ devrait fonctionner <<modern-web-archi>>.
Il a été affiné pendant 5 ans jusqu'à être décrit en détails par Roy Fielding dans sa thèse de doctorat <<fielding2000architectural>> en 2000.
Un style architectural est un ensemble de contraintes placées sur une architecture logicielle c'est à dire une abstraction décrivant les composants, les connecteurs, ainsi que les données présents au sein d'un système <<soft-archi>>.

[rest-cons]
.Dérivation des contraintes REST
["graphviz"]
-----
digraph F {
 node [shape=box, style=rounded]
 {rank=same; RR CS LS VM U }
 {rank=same; "$" CSS LCS COD }
 {rank=same; "C$SS" "LC$SS" "LCODC$SS" REST }
  o [label="", shape=point, width="0.2"]
  o -> RR [label="replicated"]
  o -> CS [label="separated"]
  o -> LS [label="layered"]
  o -> VM [label="programmable"]
  o -> U [label="uniform interface"]
  RR -> "$" [label="on-demand", weight=10]
  CS -> CSS [label="stateless", weight=10]
  CS -> LCS [label="intermediate\nprocessing"]
  CS -> COD [label="mobile"]
  LS -> LCS [weight=10]
  VM -> COD [weight=10]
  "$" -> "C$SS" [label="cacheable"]
  CSS -> "C$SS" [label="reliable", weight=10]
  LCS -> "LC$SS" [label="shared", weight=10]
  COD -> "LCODC$SS" [label="extensible", weight=10]
  U -> REST [label="simple visible\nreusable", weight=10]
  "C$SS" -> "LC$SS" [label="scalable"]
  "LC$SS" -> "LCODC$SS" [label="multi-org"]
  "LCODC$SS" -> REST
}
----

REST est composé des 6 contraintes suivantes:

Client-Serveur _(CS)_::
Cette contrainte permet la séparation des préoccupations entre le(s) serveur(s) et le(s) client(s).  Typiquement il est important de ne pas lier une interface utilisateur aux services rendus par le serveur, pour permettre la réutilisabilité des services et la variété des interfaces utilisateurs.
Dans un contexte distribué cela permet au client et au serveur d'évoluer indépendamment. 

Serveur sans état _(CSS)_::
Chaque requête envoyé par le client doit pouvoir être traitée de manière indépendante.
Cela impose de transmettre dans chacune des requêtes les données permettant d'authentifier le client.  Cela rend l'architecture robuste dans la mesure où cela limite les contraintes d'ordre dans l'envoi de messages.  Dans un contexte avec plusieurs serveurs cela permet de passer simplement à l'échelle.  Cependant cette redondance d'informations entre les requêtes impose un surcout de transfert de données.

Possible mise en cache _(\$)_::
Pour contrecarrer ce sur-coût, REST impose de pouvoir spécifier dans les messages si les informations qu'ils contiennent peuvent être garder en cache et ainsi limiter le nombre de messages transmis sur le réseau.

Interface uniforme _(U)_::

Cette contrainte est centrale à REST et consiste dans la manipulation des ressources uniquement par leur(s) représentation(s), l'utilisation de messages auto-descriptif, et l'utilisation de _l'hypermédia comme moteur de l'état de l'application_ footnote:[plus connu sous sa forme anglaise _Hypermedia As The Engine Of Application State_(HATEOAS)]

En couches _(LS)_::
Cette contrainte permet de limiter la complexité de l'architecture en revanche elle a l'inconvénient d'avoir un surcôut en terme d'exécution.

Code à la demande _(COD)_::
Ceci est une contrainte optionelle permettant au serveur d'étendre les fonctionnalités du client.

=== Architecture Web

L'architecture Web est une instance du style architectural REST.
En fait REST a été conceptualisé conjointement au World Wide Web pour permettre de décrire de manière abstraite les enjeux d'un tel système.
Nous présentons ici les différents composants que sont le protocole HTTP, les URI, et les formats de données tels HTML, XML, et JSON.

==== Protocole HTTP

Le protocole _Hypertext Transfer Protocol_ (HTTP) est un protocole texte utilisé sur le Web pour transmettre les ressources HTML, CSS, Javascript.
Ce protocole suit les contraintes définies par le style architectural REST.
Il a un rôle particulier dans l'architecture _Web_ puisqu'il sert à la fois à la communications entre les composants _Web_ et est l'unique protocole intégrant la notion de représentations de ressources.
L'accès aux ressources se fait au moyen de 4 méthodes principales `GET`, `POST`, `HEAD`, `DELETE` mais également de 5 autres méthodes moins courantes `OPTIONS`, `CONNECT`, `TRACE`, `PUT`, `PATCH`.

----
GET /hello.txt HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11
----

La standardisation des types de méthodes permettent à des clients génériques de faire des suppositions sur le propriétés de ces méthodes.
Par exemple de la méthode `GET` est nullpotent c'est à dire qu'elle ne doit pas modifier l'état des ressources, et la méthode `POST` est idempotent c'est à dire que la réception de plusieurs message ne doit produire qu'une seule action.

l'URI ne doit pas être l'API mais la représentation des données identifié par cette URI.
En pratique cela qu'il faut privélégier la récupération d'URL dans les payloads plutôt que concaténer des chaînes de caractères qui est un signe que l'URL est l'API.
//Comment traiter le versioning?

Les méchanismes de cache à différents points du réseau <<rfc7234>>.

==== Uniform Resource Identifier

Les _Uniform Resource Identifiers_ (URI) servent à nommer toute sorte des ressources (document, images, service, ...) <<rfc-3986>>.
Les URI ne sont pas des emplacements et donc ne sont pas liées à un serveur spécifique ce qui permet d'utiliser des proxies.
Comme montré par la <<rep-res,figure 2>> les URI permettent uniquement d'accéder à des représentations et non directement à des ressources.
Cette distinction permet une forme de polymorphisme en associant plusieurs représentations à une même ressource.
En pratique l'accès à ces représentations se fait au moyen du header `Accept` présent dans la requête émise vers une URI, qui dispatche alors vers la représentation la plus adaptée.

[rep-res]
.Commnunication à travers des représentations
["graphviz"]
-----
digraph G {
  rankdir=LR;
  node [shape=box, style=rounded]
  layout=dot;
  clients[shape=egg];
  clients -> représentations [label="<<envoi>>"]
  représentations -> clients [label="<<reçoit>>"]
  représentations -> ressources [dir=both label="<<met à jour>>"]
}
----

Les URI peuvent à la fois référencer des ressources statiques ou des ressources dynamiques.
Une ressource latexmath:[$R$] est un fonction latexmath:[$M_r(t)$] associant à un temps latexmath:[$t$] une entité ou valeurs.
L'ensemble des entités ou valeurs appartenant au codomaine sont équivalentes en terme de leur sémantique.
Même si ces ressources pointent sur la même valeur il s'agit bien de 2 ressources distinctes.
Ce qui identifie une ressource c'est la sémantique associé à son URI.

==== Formats de données

Lors d'une requête, il est possible pour le client de spécifier le type contenu souhaité au moyen du header `Accept` cependant il faut que le serveur recevant cette requête soit en mesure de fournir le format de donnée souhaité.
Dans la pratique les formats XML est JSON sont les plus courant pour la transmission de données structurées.

=== Hypermédia

La notion d'_hypermédia_ est cruciale dans la réalisation d'une API RESTful bien qu'elle soit trop souvent négligé.
Cette notion est une extension du contexte d'_hypertext_ au formats d'image, de son, et de vidéos.
Il désigne un réseau d'information accessible de manière non-linéaire et interactive au moyen de liens.
// Hypermedia is defined by the presence of application control information embedded within, or as a layer above , the presentation of information  <<modern-web-archi>>.

==== Bénéfices

Dans le contexte du _Web_ l'hypermédia a été choisi pour sa simplicité et généricité.
Cela a été fait dans l'objectif de rendre la participation au _Web_ accessible au plus grand nombre.
L'hypermedia permet également de stocker les différentes informations liées sur des serveurs différents et permet donc au _Web_ d'être distribué.



Découvrabilité, faible couplage, mise à jour simplifié.

==== Problèmes récurrents

* Accès aux ressources par concaténation de chaines de caractères


:numbered!:
[bibliography]
== Bibliography

[bibliography]
- [[[fielding2000architectural]]] Roy Fielding. 'Architectural styles and the design of network-based software architectures'. Addison-Wesley. University of California, Irvine Doctoral dissertation . 2000
// https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf

- [[[rfc7234]]] Roy Fielding, Mark Nottingham, and Julian Reschke. 'Hypertext transfer protocol (HTTP/1.1): Caching'. No. RFC 7234. 2014.
// https://www.rfc-editor.org/rfc/rfc7234.txt
// https://tools.ietf.org/html/rfc7234

- [[[modern-web-archi]]] Roy Fielding et Richard Taylor 'Principled design of the modern Web architecture'. ACM Transactions on Internet Technology (TOIT), 2002, vol. 2, no 2, p. 115-150.
// https://www.ics.uci.edu/~taylor/documents/2002-REST-TOIT.pdf

- [[[rest-misconception]]] Stefan Tilkov 'REST: I don't Think it Means What You Think it Does' https://www.infoq.com/presentations/rest-misconceptions Mars 2015.  visité le 05/04/2018.

- [[[soft-archi]]] Dewayne E. Perry, and Alexander L. Wolf. 'Foundations for the study of software architecture'. ACM SIGSOFT Software engineering notes 17.4 (1992): 40-52.

- [[[rest-hypertext]]] Roy T. Fielding . 'REST APIs must be hypertext-driven'. Untangled musings of Roy T. Fielding (2008): 24.
// http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven

- [[[rfc-3986]]] Berners-Lee, Tim, Roy Fielding, and Larry Masinter. 'RFC 3986, uniform resource identifier (uri): Generic syntax' (2005).
// https://tools.ietf.org/html/rfc3986

// REST, l'architecture incomprise
// https://www.youtube.com/watch?v=u_jDzcXCimM

// Liens donnés par Nicolas
//
// * https://www.infoq.com/articles/rest-introduction
// * http://apidoc.adility.com/submission-api
// * https://issues.apache.org/jira/browse/OFBIZ-4274
// * http://blog.pilotsystems.net/2012/septembre/les-api-rest
